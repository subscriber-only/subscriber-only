# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pg_query` gem.
# Please instead update this file by running `bin/tapioca gem pg_query`.

# source://pg_query//lib/pg_query/version.rb#1
class PgQuery
  # @return [PgQuery] a new instance of PgQuery
  #
  # source://pg_query//lib/pg_query/parse.rb#26
  def initialize(query, tree, warnings = T.unsafe(nil)); end

  # source://pg_query//lib/pg_query/parse.rb#56
  def aliases; end

  # source://pg_query//lib/pg_query/parse.rb#51
  def cte_names; end

  # source://pg_query//lib/pg_query/parse.rb#47
  def ddl_tables; end

  # source://pg_query//lib/pg_query/deep_dup.rb#2
  def deep_dup(obj); end

  # Reconstruct all of the parsed queries into their original form
  #
  # source://pg_query//lib/pg_query/deparse.rb#8
  def deparse(tree = T.unsafe(nil)); end

  # source://pg_query//lib/pg_query/parse.rb#43
  def dml_tables; end

  # Returns a list of columns that the query filters by - this excludes the
  # target list, but includes things like JOIN condition and WHERE clause.
  #
  # Note: This also traverses into sub-selects.
  #
  # source://pg_query//lib/pg_query/filter_columns.rb#6
  def filter_columns; end

  # source://pg_query//lib/pg_query/fingerprint.rb#4
  def fingerprint; end

  # source://pg_query//lib/pg_query/param_refs.rb#2
  def param_refs; end

  # Legacy parsetree from 0.7 and earlier versions - migrate to "tree" format if you can
  #
  # source://pg_query//lib/pg_query/legacy_parsetree.rb#3
  def parsetree; end

  # Returns the value of attribute query.
  #
  # source://pg_query//lib/pg_query/parse.rb#22
  def query; end

  # source://pg_query//lib/pg_query/parse.rb#39
  def select_tables; end

  # source://pg_query//lib/pg_query/parse.rb#35
  def tables; end

  # source://pg_query//lib/pg_query/parse.rb#61
  def tables_with_types; end

  # Returns the value of attribute tree.
  #
  # source://pg_query//lib/pg_query/parse.rb#23
  def tree; end

  # Truncates the query string to be below the specified length, first trying to
  # omit less important parts of the query, and only then cutting off the end.
  #
  # source://pg_query//lib/pg_query/truncate.rb#8
  def truncate(max_length); end

  # Returns the value of attribute warnings.
  #
  # source://pg_query//lib/pg_query/parse.rb#24
  def warnings; end

  protected

  # source://pg_query//lib/pg_query/filter_columns.rb#89
  def conditions_from_join_clauses(from_clause); end

  # source://pg_query//lib/pg_query/parse.rb#68
  def load_tables_and_aliases!; end

  # source://pg_query//lib/pg_query/parse.rb#235
  def statements_and_cte_names_for_with_clause(with_clause); end

  private

  # source://pg_query//lib/pg_query/truncate.rb#38
  def find_possible_truncations; end

  # source://pg_query//lib/pg_query/treewalker.rb#26
  def find_tree_location(normalized_parsetree, searched_location); end

  # source://pg_query//lib/pg_query/fingerprint.rb#89
  def fingerprint_list(values, hash, parent_node_name, parent_field_name); end

  # source://pg_query//lib/pg_query/fingerprint.rb#55
  def fingerprint_node(node, hash, parent_node_name = T.unsafe(nil), parent_field_name = T.unsafe(nil)); end

  # source://pg_query//lib/pg_query/fingerprint.rb#110
  def fingerprint_tree(hash); end

  # source://pg_query//lib/pg_query/fingerprint.rb#36
  def fingerprint_value(val, hash, parent_node_name, parent_field_name, need_to_write_name); end

  # @return [Boolean]
  #
  # source://pg_query//lib/pg_query/fingerprint.rb#32
  def ignored_fingerprint_value?(val); end

  # source://pg_query//lib/pg_query/param_refs.rb#38
  def param_ref_length(paramref_node); end

  # source://pg_query//lib/pg_query/treewalker.rb#33
  def transform_nodes!(parsetree); end

  # source://pg_query//lib/pg_query/legacy_parsetree.rb#78
  def transform_parsetree_a_const(node); end

  # source://pg_query//lib/pg_query/legacy_parsetree.rb#100
  def transform_string_list(list); end

  # source://pg_query//lib/pg_query/treewalker.rb#4
  def treewalker!(normalized_parsetree); end

  class << self
    def _raw_parse(_arg0); end
    def fingerprint(_arg0); end
    def normalize(_arg0); end

    # source://pg_query//lib/pg_query/parse.rb#4
    def parse(query); end
  end
end

# source://pg_query//lib/pg_query/node_types.rb#11
PgQuery::ACCESS_PRIV = T.let(T.unsafe(nil), String)

# name must be "BETWEEN"
#
# source://pg_query//lib/pg_query/node_types.rb#199
PgQuery::AEXPR_BETWEEN = T.let(T.unsafe(nil), Integer)

# name must be "BETWEEN SYMMETRIC"
#
# source://pg_query//lib/pg_query/node_types.rb#201
PgQuery::AEXPR_BETWEEN_SYM = T.let(T.unsafe(nil), Integer)

# IS DISTINCT FROM - name must be "="
#
# source://pg_query//lib/pg_query/node_types.rb#191
PgQuery::AEXPR_DISTINCT = T.let(T.unsafe(nil), Integer)

# [NOT] ILIKE - name must be "~~*" or "!~~*"
#
# source://pg_query//lib/pg_query/node_types.rb#197
PgQuery::AEXPR_ILIKE = T.let(T.unsafe(nil), Integer)

# [NOT] IN - name must be "=" or "<>"
#
# source://pg_query//lib/pg_query/node_types.rb#195
PgQuery::AEXPR_IN = T.let(T.unsafe(nil), Integer)

# [NOT] LIKE - name must be "~~" or "!~~"
#
# source://pg_query//lib/pg_query/node_types.rb#196
PgQuery::AEXPR_LIKE = T.let(T.unsafe(nil), Integer)

# name must be "NOT BETWEEN"
#
# source://pg_query//lib/pg_query/node_types.rb#200
PgQuery::AEXPR_NOT_BETWEEN = T.let(T.unsafe(nil), Integer)

# name must be "NOT BETWEEN SYMMETRIC"
#
# source://pg_query//lib/pg_query/node_types.rb#202
PgQuery::AEXPR_NOT_BETWEEN_SYM = T.let(T.unsafe(nil), Integer)

# IS NOT DISTINCT FROM - name must be "="
#
# source://pg_query//lib/pg_query/node_types.rb#192
PgQuery::AEXPR_NOT_DISTINCT = T.let(T.unsafe(nil), Integer)

# NULLIF - name must be "="
#
# source://pg_query//lib/pg_query/node_types.rb#193
PgQuery::AEXPR_NULLIF = T.let(T.unsafe(nil), Integer)

# IS [NOT] OF - name must be "=" or "<>"
#
# source://pg_query//lib/pg_query/node_types.rb#194
PgQuery::AEXPR_OF = T.let(T.unsafe(nil), Integer)

# normal operator
#
# source://pg_query//lib/pg_query/node_types.rb#188
PgQuery::AEXPR_OP = T.let(T.unsafe(nil), Integer)

# scalar op ALL (array)
#
# source://pg_query//lib/pg_query/node_types.rb#190
PgQuery::AEXPR_OP_ALL = T.let(T.unsafe(nil), Integer)

# scalar op ANY (array)
#
# source://pg_query//lib/pg_query/node_types.rb#189
PgQuery::AEXPR_OP_ANY = T.let(T.unsafe(nil), Integer)

# nameless dummy node for parentheses
#
# source://pg_query//lib/pg_query/node_types.rb#203
PgQuery::AEXPR_PAREN = T.let(T.unsafe(nil), Integer)

# [NOT] SIMILAR - name must be "~" or "!~"
#
# source://pg_query//lib/pg_query/node_types.rb#198
PgQuery::AEXPR_SIMILAR = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#12
PgQuery::ALIAS = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#13
PgQuery::ALTER_TABLE_CMD = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#14
PgQuery::ALTER_TABLE_STMT = T.let(T.unsafe(nil), String)

# add column
#
# source://pg_query//lib/pg_query/node_types.rb#231
PgQuery::AT_AddColumn = T.let(T.unsafe(nil), Integer)

# internal to commands/tablecmds.c
#
# source://pg_query//lib/pg_query/node_types.rb#232
PgQuery::AT_AddColumnRecurse = T.let(T.unsafe(nil), Integer)

# implicitly via CREATE OR REPLACE VIEW
#
# source://pg_query//lib/pg_query/node_types.rb#233
PgQuery::AT_AddColumnToView = T.let(T.unsafe(nil), Integer)

# add constraint
#
# source://pg_query//lib/pg_query/node_types.rb#245
PgQuery::AT_AddConstraint = T.let(T.unsafe(nil), Integer)

# internal to commands/tablecmds.c
#
# source://pg_query//lib/pg_query/node_types.rb#246
PgQuery::AT_AddConstraintRecurse = T.let(T.unsafe(nil), Integer)

# ADD IDENTITY
#
# source://pg_query//lib/pg_query/node_types.rb#294
PgQuery::AT_AddIdentity = T.let(T.unsafe(nil), Integer)

# add index
#
# source://pg_query//lib/pg_query/node_types.rb#243
PgQuery::AT_AddIndex = T.let(T.unsafe(nil), Integer)

# add constraint using existing index
#
# source://pg_query//lib/pg_query/node_types.rb#252
PgQuery::AT_AddIndexConstraint = T.let(T.unsafe(nil), Integer)

# INHERIT parent
#
# source://pg_query//lib/pg_query/node_types.rb#282
PgQuery::AT_AddInherit = T.let(T.unsafe(nil), Integer)

# OF <type_name>
#
# source://pg_query//lib/pg_query/node_types.rb#284
PgQuery::AT_AddOf = T.let(T.unsafe(nil), Integer)

# SET WITH OIDS
#
# source://pg_query//lib/pg_query/node_types.rb#263
PgQuery::AT_AddOids = T.let(T.unsafe(nil), Integer)

# internal to commands/tablecmds.c
#
# source://pg_query//lib/pg_query/node_types.rb#264
PgQuery::AT_AddOidsRecurse = T.let(T.unsafe(nil), Integer)

# alter column OPTIONS (...)
#
# source://pg_query//lib/pg_query/node_types.rb#257
PgQuery::AT_AlterColumnGenericOptions = T.let(T.unsafe(nil), Integer)

# alter column type
#
# source://pg_query//lib/pg_query/node_types.rb#256
PgQuery::AT_AlterColumnType = T.let(T.unsafe(nil), Integer)

# alter constraint
#
# source://pg_query//lib/pg_query/node_types.rb#248
PgQuery::AT_AlterConstraint = T.let(T.unsafe(nil), Integer)

# ATTACH PARTITION
#
# source://pg_query//lib/pg_query/node_types.rb#292
PgQuery::AT_AttachPartition = T.let(T.unsafe(nil), Integer)

# change owner
#
# source://pg_query//lib/pg_query/node_types.rb#258
PgQuery::AT_ChangeOwner = T.let(T.unsafe(nil), Integer)

# CLUSTER ON
#
# source://pg_query//lib/pg_query/node_types.rb#259
PgQuery::AT_ClusterOn = T.let(T.unsafe(nil), Integer)

# alter column default
#
# source://pg_query//lib/pg_query/node_types.rb#234
PgQuery::AT_ColumnDefault = T.let(T.unsafe(nil), Integer)

# DETACH PARTITION
#
# source://pg_query//lib/pg_query/node_types.rb#293
PgQuery::AT_DetachPartition = T.let(T.unsafe(nil), Integer)

# DISABLE ROW SECURITY
#
# source://pg_query//lib/pg_query/node_types.rb#288
PgQuery::AT_DisableRowSecurity = T.let(T.unsafe(nil), Integer)

# DISABLE RULE name
#
# source://pg_query//lib/pg_query/node_types.rb#281
PgQuery::AT_DisableRule = T.let(T.unsafe(nil), Integer)

# DISABLE TRIGGER name
#
# source://pg_query//lib/pg_query/node_types.rb#273
PgQuery::AT_DisableTrig = T.let(T.unsafe(nil), Integer)

# DISABLE TRIGGER ALL
#
# source://pg_query//lib/pg_query/node_types.rb#275
PgQuery::AT_DisableTrigAll = T.let(T.unsafe(nil), Integer)

# DISABLE TRIGGER USER
#
# source://pg_query//lib/pg_query/node_types.rb#277
PgQuery::AT_DisableTrigUser = T.let(T.unsafe(nil), Integer)

# SET WITHOUT CLUSTER
#
# source://pg_query//lib/pg_query/node_types.rb#260
PgQuery::AT_DropCluster = T.let(T.unsafe(nil), Integer)

# drop column
#
# source://pg_query//lib/pg_query/node_types.rb#241
PgQuery::AT_DropColumn = T.let(T.unsafe(nil), Integer)

# internal to commands/tablecmds.c
#
# source://pg_query//lib/pg_query/node_types.rb#242
PgQuery::AT_DropColumnRecurse = T.let(T.unsafe(nil), Integer)

# drop constraint
#
# source://pg_query//lib/pg_query/node_types.rb#253
PgQuery::AT_DropConstraint = T.let(T.unsafe(nil), Integer)

# internal to commands/tablecmds.c
#
# source://pg_query//lib/pg_query/node_types.rb#254
PgQuery::AT_DropConstraintRecurse = T.let(T.unsafe(nil), Integer)

# DROP IDENTITY
#
# source://pg_query//lib/pg_query/node_types.rb#296
PgQuery::AT_DropIdentity = T.let(T.unsafe(nil), Integer)

# NO INHERIT parent
#
# source://pg_query//lib/pg_query/node_types.rb#283
PgQuery::AT_DropInherit = T.let(T.unsafe(nil), Integer)

# alter column drop not null
#
# source://pg_query//lib/pg_query/node_types.rb#235
PgQuery::AT_DropNotNull = T.let(T.unsafe(nil), Integer)

# NOT OF
#
# source://pg_query//lib/pg_query/node_types.rb#285
PgQuery::AT_DropOf = T.let(T.unsafe(nil), Integer)

# SET WITHOUT OIDS
#
# source://pg_query//lib/pg_query/node_types.rb#265
PgQuery::AT_DropOids = T.let(T.unsafe(nil), Integer)

# ENABLE ALWAYS RULE name
#
# source://pg_query//lib/pg_query/node_types.rb#279
PgQuery::AT_EnableAlwaysRule = T.let(T.unsafe(nil), Integer)

# ENABLE ALWAYS TRIGGER name
#
# source://pg_query//lib/pg_query/node_types.rb#271
PgQuery::AT_EnableAlwaysTrig = T.let(T.unsafe(nil), Integer)

# ENABLE REPLICA RULE name
#
# source://pg_query//lib/pg_query/node_types.rb#280
PgQuery::AT_EnableReplicaRule = T.let(T.unsafe(nil), Integer)

# ENABLE REPLICA TRIGGER name
#
# source://pg_query//lib/pg_query/node_types.rb#272
PgQuery::AT_EnableReplicaTrig = T.let(T.unsafe(nil), Integer)

# ENABLE ROW SECURITY
#
# source://pg_query//lib/pg_query/node_types.rb#287
PgQuery::AT_EnableRowSecurity = T.let(T.unsafe(nil), Integer)

# ENABLE RULE name
#
# source://pg_query//lib/pg_query/node_types.rb#278
PgQuery::AT_EnableRule = T.let(T.unsafe(nil), Integer)

# ENABLE TRIGGER name
#
# source://pg_query//lib/pg_query/node_types.rb#270
PgQuery::AT_EnableTrig = T.let(T.unsafe(nil), Integer)

# ENABLE TRIGGER ALL
#
# source://pg_query//lib/pg_query/node_types.rb#274
PgQuery::AT_EnableTrigAll = T.let(T.unsafe(nil), Integer)

# ENABLE TRIGGER USER
#
# source://pg_query//lib/pg_query/node_types.rb#276
PgQuery::AT_EnableTrigUser = T.let(T.unsafe(nil), Integer)

# FORCE ROW SECURITY
#
# source://pg_query//lib/pg_query/node_types.rb#289
PgQuery::AT_ForceRowSecurity = T.let(T.unsafe(nil), Integer)

# OPTIONS (...)
#
# source://pg_query//lib/pg_query/node_types.rb#291
PgQuery::AT_GenericOptions = T.let(T.unsafe(nil), Integer)

# NO FORCE ROW SECURITY
#
# source://pg_query//lib/pg_query/node_types.rb#290
PgQuery::AT_NoForceRowSecurity = T.let(T.unsafe(nil), Integer)

# pre-processed add constraint (local in parser/parse_utilcmd.c)
#
# source://pg_query//lib/pg_query/node_types.rb#251
PgQuery::AT_ProcessedConstraint = T.let(T.unsafe(nil), Integer)

# internal to commands/tablecmds.c
#
# source://pg_query//lib/pg_query/node_types.rb#255
PgQuery::AT_ReAddComment = T.let(T.unsafe(nil), Integer)

# internal to commands/tablecmds.c
#
# source://pg_query//lib/pg_query/node_types.rb#247
PgQuery::AT_ReAddConstraint = T.let(T.unsafe(nil), Integer)

# internal to commands/tablecmds.c
#
# source://pg_query//lib/pg_query/node_types.rb#244
PgQuery::AT_ReAddIndex = T.let(T.unsafe(nil), Integer)

# replace reloption list in its entirety
#
# source://pg_query//lib/pg_query/node_types.rb#269
PgQuery::AT_ReplaceRelOptions = T.let(T.unsafe(nil), Integer)

# REPLICA IDENTITY
#
# source://pg_query//lib/pg_query/node_types.rb#286
PgQuery::AT_ReplicaIdentity = T.let(T.unsafe(nil), Integer)

# alter column reset ( options )
#
# source://pg_query//lib/pg_query/node_types.rb#239
PgQuery::AT_ResetOptions = T.let(T.unsafe(nil), Integer)

# RESET (...) -- AM specific parameters
#
# source://pg_query//lib/pg_query/node_types.rb#268
PgQuery::AT_ResetRelOptions = T.let(T.unsafe(nil), Integer)

# SET identity column options
#
# source://pg_query//lib/pg_query/node_types.rb#295
PgQuery::AT_SetIdentity = T.let(T.unsafe(nil), Integer)

# SET LOGGED
#
# source://pg_query//lib/pg_query/node_types.rb#261
PgQuery::AT_SetLogged = T.let(T.unsafe(nil), Integer)

# alter column set not null
#
# source://pg_query//lib/pg_query/node_types.rb#236
PgQuery::AT_SetNotNull = T.let(T.unsafe(nil), Integer)

# alter column set ( options )
#
# source://pg_query//lib/pg_query/node_types.rb#238
PgQuery::AT_SetOptions = T.let(T.unsafe(nil), Integer)

# SET (...) -- AM specific parameters
#
# source://pg_query//lib/pg_query/node_types.rb#267
PgQuery::AT_SetRelOptions = T.let(T.unsafe(nil), Integer)

# alter column set statistics
#
# source://pg_query//lib/pg_query/node_types.rb#237
PgQuery::AT_SetStatistics = T.let(T.unsafe(nil), Integer)

# alter column set storage
#
# source://pg_query//lib/pg_query/node_types.rb#240
PgQuery::AT_SetStorage = T.let(T.unsafe(nil), Integer)

# SET TABLESPACE
#
# source://pg_query//lib/pg_query/node_types.rb#266
PgQuery::AT_SetTableSpace = T.let(T.unsafe(nil), Integer)

# SET UNLOGGED
#
# source://pg_query//lib/pg_query/node_types.rb#262
PgQuery::AT_SetUnLogged = T.let(T.unsafe(nil), Integer)

# validate constraint
#
# source://pg_query//lib/pg_query/node_types.rb#249
PgQuery::AT_ValidateConstraint = T.let(T.unsafe(nil), Integer)

# internal to commands/tablecmds.c
#
# source://pg_query//lib/pg_query/node_types.rb#250
PgQuery::AT_ValidateConstraintRecurse = T.let(T.unsafe(nil), Integer)

# NODE TYPES
#
# source://pg_query//lib/pg_query/node_types.rb#5
PgQuery::A_ARRAY_EXPR = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#6
PgQuery::A_CONST = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#7
PgQuery::A_EXPR = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#8
PgQuery::A_INDICES = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#9
PgQuery::A_INDIRECTION = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#10
PgQuery::A_STAR = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/truncate.rb#4
PgQuery::A_TRUNCATED = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#15
PgQuery::BIT_STRING = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#17
PgQuery::BOOLEAN_TEST = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#183
PgQuery::BOOLEAN_TEST_FALSE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#184
PgQuery::BOOLEAN_TEST_NOT_FALSE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#182
PgQuery::BOOLEAN_TEST_NOT_TRUE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#186
PgQuery::BOOLEAN_TEST_NOT_UNKNOWN = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#181
PgQuery::BOOLEAN_TEST_TRUE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#185
PgQuery::BOOLEAN_TEST_UNKNOWN = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#16
PgQuery::BOOL_EXPR = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#177
PgQuery::BOOL_EXPR_AND = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#179
PgQuery::BOOL_EXPR_NOT = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#178
PgQuery::BOOL_EXPR_OR = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#18
PgQuery::CASE_EXPR = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#19
PgQuery::CASE_WHEN = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#20
PgQuery::CHECK_POINT_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#21
PgQuery::CLOSE_PORTAL_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#22
PgQuery::COALESCE_EXPR = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#23
PgQuery::COLLATE_CLAUSE = T.let(T.unsafe(nil), String)

# FIELDS
#
# source://pg_query//lib/pg_query/node_types.rb#104
PgQuery::COLS_FIELD = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#24
PgQuery::COLUMN_DEF = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#25
PgQuery::COLUMN_REF = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#26
PgQuery::COMMON_TABLE_EXPR = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#27
PgQuery::COMPOSITE_TYPE_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#28
PgQuery::CONSTRAINT = T.let(T.unsafe(nil), String)

# attributes for previous constraint node
#
# source://pg_query//lib/pg_query/node_types.rb#123
PgQuery::CONSTR_TYPE_ATTR_DEFERRABLE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#125
PgQuery::CONSTR_TYPE_ATTR_DEFERRED = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#126
PgQuery::CONSTR_TYPE_ATTR_IMMEDIATE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#124
PgQuery::CONSTR_TYPE_ATTR_NOT_DEFERRABLE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#118
PgQuery::CONSTR_TYPE_CHECK = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#116
PgQuery::CONSTR_TYPE_DEFAULT = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#121
PgQuery::CONSTR_TYPE_EXCLUSION = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#122
PgQuery::CONSTR_TYPE_FOREIGN = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#117
PgQuery::CONSTR_TYPE_IDENTITY = T.let(T.unsafe(nil), Integer)

# not standard SQL, but a lot of people expect it
#
# source://pg_query//lib/pg_query/node_types.rb#115
PgQuery::CONSTR_TYPE_NOTNULL = T.let(T.unsafe(nil), Integer)

# ENUMS
#
# source://pg_query//lib/pg_query/node_types.rb#114
PgQuery::CONSTR_TYPE_NULL = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#119
PgQuery::CONSTR_TYPE_PRIMARY = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#120
PgQuery::CONSTR_TYPE_UNIQUE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#29
PgQuery::COPY_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#30
PgQuery::CREATE_CAST_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#31
PgQuery::CREATE_DOMAIN_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#32
PgQuery::CREATE_ENUM_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#33
PgQuery::CREATE_FUNCTION_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#34
PgQuery::CREATE_RANGE_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#35
PgQuery::CREATE_SCHEMA_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#36
PgQuery::CREATE_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#37
PgQuery::CREATE_TABLE_AS_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#38
PgQuery::CREATE_TRIG_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#39
PgQuery::DEALLOCATE_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#40
PgQuery::DECLARE_CURSOR_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#42
PgQuery::DEFINE_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#41
PgQuery::DEF_ELEM = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#43
PgQuery::DELETE_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#44
PgQuery::DISCARD_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#45
PgQuery::DO_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#49
PgQuery::DROP_ROLE = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#46
PgQuery::DROP_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#47
PgQuery::DROP_SUBSCRIPTION = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#48
PgQuery::DROP_TABLESPACE = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/deparse/alter_table.rb#2
module PgQuery::Deparse
  extend ::PgQuery::Deparse

  # Given one element of the PgQuery#parsetree reconstruct it back into the
  # original query.
  #
  # source://pg_query//lib/pg_query/deparse.rb#20
  def from(item); end

  private

  # source://pg_query//lib/pg_query/deparse.rb#296
  def deparse_a_arrayexp(node); end

  # source://pg_query//lib/pg_query/deparse.rb#302
  def deparse_a_const(node); end

  # source://pg_query//lib/pg_query/deparse.rb#328
  def deparse_a_indices(node); end

  # source://pg_query//lib/pg_query/deparse.rb#310
  def deparse_a_indirection(node); end

  # source://pg_query//lib/pg_query/deparse.rb#306
  def deparse_a_star(_node); end

  # source://pg_query//lib/pg_query/deparse.rb#519
  def deparse_access_priv(node); end

  # source://pg_query//lib/pg_query/deparse.rb#575
  def deparse_aexpr(node, context = T.unsafe(nil)); end

  # source://pg_query//lib/pg_query/deparse.rb#616
  def deparse_aexpr_all(node); end

  # source://pg_query//lib/pg_query/deparse.rb#609
  def deparse_aexpr_any(node); end

  # source://pg_query//lib/pg_query/deparse.rb#623
  def deparse_aexpr_between(node); end

  # source://pg_query//lib/pg_query/deparse.rb#544
  def deparse_aexpr_ilike(node); end

  # source://pg_query//lib/pg_query/deparse.rb#532
  def deparse_aexpr_in(node); end

  # source://pg_query//lib/pg_query/deparse.rb#538
  def deparse_aexpr_like(node); end

  # source://pg_query//lib/pg_query/deparse.rb#639
  def deparse_aexpr_nullif(node); end

  # source://pg_query//lib/pg_query/deparse.rb#332
  def deparse_alias(node); end

  # source://pg_query//lib/pg_query/deparse.rb#341
  def deparse_alter_table(node); end

  # source://pg_query//lib/pg_query/deparse.rb#357
  def deparse_alter_table_cmd(node); end

  # source://pg_query//lib/pg_query/deparse.rb#587
  def deparse_bool_expr_and(node); end

  # source://pg_query//lib/pg_query/deparse.rb#550
  def deparse_bool_expr_not(node); end

  # source://pg_query//lib/pg_query/deparse.rb#598
  def deparse_bool_expr_or(node); end

  # source://pg_query//lib/pg_query/deparse.rb#562
  def deparse_boolean_test(node); end

  # source://pg_query//lib/pg_query/deparse.rb#799
  def deparse_case(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1455
  def deparse_coalesce(node); end

  # source://pg_query//lib/pg_query/deparse.rb#711
  def deparse_collate(node); end

  # source://pg_query//lib/pg_query/deparse.rb#811
  def deparse_columndef(node); end

  # source://pg_query//lib/pg_query/deparse.rb#290
  def deparse_columnref(node, context = T.unsafe(nil)); end

  # source://pg_query//lib/pg_query/deparse.rb#830
  def deparse_composite_type(node); end

  # source://pg_query//lib/pg_query/deparse.rb#839
  def deparse_constraint(node); end

  # source://pg_query//lib/pg_query/deparse.rb#879
  def deparse_copy(node); end

  # source://pg_query//lib/pg_query/deparse.rb#894
  def deparse_copy_output(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1483
  def deparse_create_aggregate(node); end

  # source://pg_query//lib/pg_query/deparse.rb#909
  def deparse_create_cast(node); end

  # source://pg_query//lib/pg_query/deparse.rb#929
  def deparse_create_domain(node); end

  # source://pg_query//lib/pg_query/deparse.rb#900
  def deparse_create_enum(node); end

  # source://pg_query//lib/pg_query/deparse.rb#941
  def deparse_create_function(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1497
  def deparse_create_operator(node); end

  # source://pg_query//lib/pg_query/deparse.rb#958
  def deparse_create_range(node); end

  # source://pg_query//lib/pg_query/deparse.rb#973
  def deparse_create_schema(node); end

  # source://pg_query//lib/pg_query/deparse.rb#982
  def deparse_create_table(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1009
  def deparse_create_table_as(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1509
  def deparse_create_type(node); end

  # source://pg_query//lib/pg_query/deparse.rb#791
  def deparse_cte(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1459
  def deparse_defelem(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1474
  def deparse_define_stmt(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1525
  def deparse_delete_from(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1555
  def deparse_discard(node); end

  # source://pg_query//lib/pg_query/deparse.rb#782
  def deparse_do_stmt(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1564
  def deparse_drop(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1637
  def deparse_drop_role(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1644
  def deparse_drop_subscription(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1651
  def deparse_drop_tablespace(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1032
  def deparse_execute(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1658
  def deparse_explain(node); end

  # source://pg_query//lib/pg_query/deparse.rb#412
  def deparse_funccall(node); end

  # source://pg_query//lib/pg_query/deparse.rb#457
  def deparse_functionparameter(node); end

  # source://pg_query//lib/pg_query/deparse.rb#473
  def deparse_grant(node); end

  # source://pg_query//lib/pg_query/deparse.rb#502
  def deparse_grant_objtype(node); end

  # source://pg_query//lib/pg_query/deparse.rb#461
  def deparse_grant_role(node); end

  # source://pg_query//lib/pg_query/deparse.rb#239
  def deparse_identifier(ident, escape_always: T.unsafe(nil)); end

  # source://pg_query//lib/pg_query/deparse.rb#1212
  def deparse_insert_into(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1241
  def deparse_insert_onconflict(node); end

  # Deparses interval type expressions like `interval year to month` or
  # `interval hour to second(5)`
  #
  # source://pg_query//lib/pg_query/deparse.rb#1407
  def deparse_interval_type(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1039
  def deparse_into_clause(node); end

  # source://pg_query//lib/pg_query/deparse.rb#26
  def deparse_item(item, context = T.unsafe(nil)); end

  # source://pg_query//lib/pg_query/deparse.rb#235
  def deparse_item_list(nodes, context = T.unsafe(nil)); end

  # source://pg_query//lib/pg_query/deparse.rb#645
  def deparse_joinexpr(node); end

  # source://pg_query//lib/pg_query/deparse.rb#675
  def deparse_lock(node); end

  # source://pg_query//lib/pg_query/deparse.rb#689
  def deparse_lockingclause(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1425
  def deparse_nulltest(node); end

  # source://pg_query//lib/pg_query/deparse.rb#371
  def deparse_object_with_args(node); end

  # source://pg_query//lib/pg_query/deparse.rb#381
  def deparse_paramref(node); end

  # source://pg_query//lib/pg_query/deparse.rb#389
  def deparse_prepare(node); end

  # source://pg_query//lib/pg_query/deparse.rb#566
  def deparse_range_function(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1065
  def deparse_rangesubselect(node); end

  # source://pg_query//lib/pg_query/deparse.rb#248
  def deparse_rangevar(node); end

  # source://pg_query//lib/pg_query/deparse.rb#257
  def deparse_raw_stmt(node); end

  # source://pg_query//lib/pg_query/deparse.rb#275
  def deparse_renamestmt(node); end

  # source://pg_query//lib/pg_query/deparse.rb#261
  def deparse_renamestmt_decision(node, type); end

  # source://pg_query//lib/pg_query/deparse.rb#398
  def deparse_restarget(node, context); end

  # source://pg_query//lib/pg_query/deparse.rb#525
  def deparse_role_spec(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1076
  def deparse_row(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1080
  def deparse_select(node); end

  # source://pg_query//lib/pg_query/deparse.rb#701
  def deparse_sortby(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1188
  def deparse_sql_value_function(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1051
  def deparse_sublink(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1444
  def deparse_transaction(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1331
  def deparse_typecast(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1343
  def deparse_typename(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1364
  def deparse_typename_cast(names, arguments); end

  # source://pg_query//lib/pg_query/deparse.rb#1275
  def deparse_update(node); end

  # source://pg_query//lib/pg_query/deparse.rb#773
  def deparse_vacuum_options(node); end

  # source://pg_query//lib/pg_query/deparse.rb#762
  def deparse_vacuum_stmt(node); end

  # source://pg_query//lib/pg_query/deparse.rb#752
  def deparse_variable_set_stmt(node); end

  # source://pg_query//lib/pg_query/deparse.rb#728
  def deparse_viewstmt(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1043
  def deparse_when(node); end

  # source://pg_query//lib/pg_query/deparse.rb#435
  def deparse_windowdef(node); end

  # source://pg_query//lib/pg_query/deparse.rb#719
  def deparse_with_clause(node); end

  # source://pg_query//lib/pg_query/deparse.rb#1327
  def make_string(str); end

  # Builds a properly-qualified reference to a built-in Postgres type.
  #
  # Inspired by SystemTypeName in Postgres' gram.y, but without node name
  # and locations, to simplify comparison.
  #
  # source://pg_query//lib/pg_query/deparse.rb#1317
  def make_system_type_name(name); end

  # The PG parser adds several pieces of view data onto the RANGEVAR
  # that need to be printed before deparse_rangevar is called.
  #
  # source://pg_query//lib/pg_query/deparse.rb#1672
  def relpersistence(rangevar); end
end

# source://pg_query//lib/pg_query/deparse/alter_table.rb#3
module PgQuery::Deparse::AlterTable
  class << self
    # Returns a list of strings of length one or length two. The first string
    # will be placed before the column name and the second, if present, will be
    # placed after.
    #
    # If node['subtype'] is the integer 4 (AT_DropNotNull),
    # then return value of this method will be:
    #
    #   ['ALTER COLUMN', 'DROP NOT NULL']
    #
    # Which will be composed into the SQL as:
    #
    #   ALTER COLUMN {column_name} DROP NOT NULL
    #
    # source://pg_query//lib/pg_query/deparse/alter_table.rb#17
    def commands(node); end
  end
end

# source://pg_query//lib/pg_query/deparse/alter_table.rb#22
PgQuery::Deparse::AlterTable::ALTER_TABLE_TYPES_MAPPING = T.let(T.unsafe(nil), Hash)

# source://pg_query//lib/pg_query/deparse.rb#554
PgQuery::Deparse::BOOLEAN_TEST_TYPE_TO_STRING = T.let(T.unsafe(nil), Hash)

# source://pg_query//lib/pg_query/deparse/interval.rb#3
module PgQuery::Deparse::Interval
  class << self
    # A type called 'interval hour to minute' is stored in a compressed way by
    # simplifying 'hour to minute' to a simple integer. This integer is computed
    # by looking up the arbitrary number (always a power of two) for 'hour' and
    # the one for 'minute' and XORing them together.
    #
    # For example, when parsing "interval hour to minute":
    #
    #   HOUR_MASK = 10
    #   MINUTE_MASK = 11
    #   mask = (1 << 10) | (1 << 11)
    #   mask = 1024 | 2048
    #   mask =     (010000000000
    #                   xor
    #               100000000000)
    #   mask =      110000000000
    #   mask = 3072
    #
    #   Postgres will store this type as 'interval,3072'
    #   We deparse it by simply reversing that process.
    #
    # source://pg_query//lib/pg_query/deparse/interval.rb#24
    def from_int(int); end
  end
end

# source://pg_query//lib/pg_query/deparse/interval.rb#61
PgQuery::Deparse::Interval::KEYS = T.let(T.unsafe(nil), Hash)

# From src/include/utils/datetime.h
# The number is the power of 2 used for the mask.
#
# source://pg_query//lib/pg_query/deparse/interval.rb#30
PgQuery::Deparse::Interval::MASKS = T.let(T.unsafe(nil), Hash)

# Postgres stores the interval 'day second' as 'day hour minute second' so
# we need to reconstruct the sql with only the largest and smallest time
# values. Since the rules for this are hardcoded in the grammar (and the
# above list is not sorted in any sensible way) it makes sense to hardcode
# the patterns here, too.
#
#  This hash takes the form:
#
#      { (1 << 1) | (1 << 2) => 'year to month' }
#
#  Which is:
#
#      { 6 => 'year to month' }
#
# source://pg_query//lib/pg_query/deparse/interval.rb#77
PgQuery::Deparse::Interval::SQL_BY_MASK = T.let(T.unsafe(nil), Hash)

# Keywords that need to be escaped during deparsing. This matches they keywords
# excaped by quote_identifier in Postgres ruleutils.c. You can refresh this
# list using the kwlist.h file (make sure to ignore UNRESERVED_KEYWORD entries)
#
# source://pg_query//lib/pg_query/deparse/keywords.rb#6
PgQuery::Deparse::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://pg_query//lib/pg_query/deparse.rb#683
PgQuery::Deparse::LOCK_CLAUSE_STRENGTH = T.let(T.unsafe(nil), Hash)

# source://pg_query//lib/pg_query/deparse/rename.rb#3
module PgQuery::Deparse::Rename
  class << self
    # relation, subname and object is the array key in the node.
    # Array return five value. First is the type like a TRIGGER, TABLE, DOMAIN
    # Other values may be parameter or SQL key.
    #
    # If node['renameType'] is the integer 13 (OBJECT_TYPE_DOMCONSTRAINT),
    # then return value of this method will be:
    #
    #   %w[DOMAIN object RENAME CONSTRAINT subname]
    #
    # Which will be composed into the SQL as:
    #
    #   ALTER {type} {name} RENAME CONSTRAINT {subname} TO {newname}
    #
    # source://pg_query//lib/pg_query/deparse/rename.rb#17
    def commands(node); end
  end
end

# source://pg_query//lib/pg_query/deparse/rename.rb#22
PgQuery::Deparse::Rename::RENAME_MAPPING = T.let(T.unsafe(nil), Hash)

# source://pg_query//lib/pg_query/deparse.rb#1436
PgQuery::Deparse::TRANSACTION_CMDS = T.let(T.unsafe(nil), Hash)

# source://pg_query//lib/pg_query/node_types.rb#50
PgQuery::EXECUTE_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#51
PgQuery::EXPLAIN_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#52
PgQuery::FETCH_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/fingerprint.rb#12
PgQuery::FINGERPRINT_VERSION = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#53
PgQuery::FLOAT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#105
PgQuery::FROM_CLAUSE_FIELD = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#55
PgQuery::FUNCTION_PARAMETER = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#54
PgQuery::FUNC_CALL = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/fingerprint.rb#14
class PgQuery::FingerprintSubHash
  # @return [FingerprintSubHash] a new instance of FingerprintSubHash
  #
  # source://pg_query//lib/pg_query/fingerprint.rb#17
  def initialize; end

  # source://pg_query//lib/pg_query/fingerprint.rb#25
  def flush_to(hash); end

  # Returns the value of attribute parts.
  #
  # source://pg_query//lib/pg_query/fingerprint.rb#15
  def parts; end

  # source://pg_query//lib/pg_query/fingerprint.rb#21
  def update(part); end
end

# source://pg_query//lib/pg_query/node_types.rb#56
PgQuery::GRANT_ROLE_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#57
PgQuery::GRANT_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#58
PgQuery::INDEX_ELEM = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#59
PgQuery::INDEX_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#60
PgQuery::INSERT_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#62
PgQuery::INTEGER = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#63
PgQuery::INTO_CLAUSE = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#61
PgQuery::INT_LIST = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#64
PgQuery::JOIN_EXPR = T.let(T.unsafe(nil), String)

# FOR KEY SHARE
#
# source://pg_query//lib/pg_query/node_types.rb#226
PgQuery::LCS_FORKEYSHARE = T.let(T.unsafe(nil), Integer)

# FOR NO KEY UPDATE
#
# source://pg_query//lib/pg_query/node_types.rb#228
PgQuery::LCS_FORNOKEYUPDATE = T.let(T.unsafe(nil), Integer)

# FOR SHARE
#
# source://pg_query//lib/pg_query/node_types.rb#227
PgQuery::LCS_FORSHARE = T.let(T.unsafe(nil), Integer)

# FOR UPDATE
#
# source://pg_query//lib/pg_query/node_types.rb#229
PgQuery::LCS_FORUPDATE = T.let(T.unsafe(nil), Integer)

# no such clause - only used in PlanRowMark
#
# source://pg_query//lib/pg_query/node_types.rb#225
PgQuery::LCS_NONE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/legacy_parsetree.rb#74
PgQuery::LEGACY_CONSTRAINT_TYPES = T.let(T.unsafe(nil), Hash)

# source://pg_query//lib/pg_query/legacy_parsetree.rb#51
PgQuery::LEGACY_NODE_NAMES = T.let(T.unsafe(nil), Hash)

# source://pg_query//lib/pg_query/node_types.rb#66
PgQuery::LOCKING_CLAUSE = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#65
PgQuery::LOCK_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#67
PgQuery::NULL = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#68
PgQuery::NULL_TEST = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#128
PgQuery::OBJECT_TYPE_ACCESS_METHOD = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#129
PgQuery::OBJECT_TYPE_AGGREGATE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#130
PgQuery::OBJECT_TYPE_AMOP = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#131
PgQuery::OBJECT_TYPE_AMPROC = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#132
PgQuery::OBJECT_TYPE_ATTRIBUTE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#133
PgQuery::OBJECT_TYPE_CAST = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#135
PgQuery::OBJECT_TYPE_COLLATION = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#134
PgQuery::OBJECT_TYPE_COLUMN = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#136
PgQuery::OBJECT_TYPE_CONVERSION = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#137
PgQuery::OBJECT_TYPE_DATABASE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#139
PgQuery::OBJECT_TYPE_DEFACL = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#138
PgQuery::OBJECT_TYPE_DEFAULT = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#140
PgQuery::OBJECT_TYPE_DOMAIN = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#141
PgQuery::OBJECT_TYPE_DOMCONSTRAINT = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#142
PgQuery::OBJECT_TYPE_EVENT_TRIGGER = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#143
PgQuery::OBJECT_TYPE_EXTENSION = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#144
PgQuery::OBJECT_TYPE_FDW = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#145
PgQuery::OBJECT_TYPE_FOREIGN_SERVER = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#146
PgQuery::OBJECT_TYPE_FOREIGN_TABLE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#147
PgQuery::OBJECT_TYPE_FUNCTION = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#148
PgQuery::OBJECT_TYPE_INDEX = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#149
PgQuery::OBJECT_TYPE_LANGUAGE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#150
PgQuery::OBJECT_TYPE_LARGEOBJECT = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#151
PgQuery::OBJECT_TYPE_MATVIEW = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#152
PgQuery::OBJECT_TYPE_OPCLASS = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#153
PgQuery::OBJECT_TYPE_OPERATOR = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#154
PgQuery::OBJECT_TYPE_OPFAMILY = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#155
PgQuery::OBJECT_TYPE_POLICY = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#156
PgQuery::OBJECT_TYPE_PUBLICATION = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#157
PgQuery::OBJECT_TYPE_PUBLICATION_REL = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#158
PgQuery::OBJECT_TYPE_ROLE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#159
PgQuery::OBJECT_TYPE_RULE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#160
PgQuery::OBJECT_TYPE_SCHEMA = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#161
PgQuery::OBJECT_TYPE_SEQUENCE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#163
PgQuery::OBJECT_TYPE_STATISTIC_EXT = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#162
PgQuery::OBJECT_TYPE_SUBSCRIPTION = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#164
PgQuery::OBJECT_TYPE_TABCONSTRAINT = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#165
PgQuery::OBJECT_TYPE_TABLE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#166
PgQuery::OBJECT_TYPE_TABLESPACE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#167
PgQuery::OBJECT_TYPE_TRANSFORM = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#168
PgQuery::OBJECT_TYPE_TRIGGER = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#169
PgQuery::OBJECT_TYPE_TSCONFIGURATION = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#170
PgQuery::OBJECT_TYPE_TSDICTIONARY = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#171
PgQuery::OBJECT_TYPE_TSPARSER = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#172
PgQuery::OBJECT_TYPE_TSTEMPLATE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#173
PgQuery::OBJECT_TYPE_TYPE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#174
PgQuery::OBJECT_TYPE_USER_MAPPING = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#175
PgQuery::OBJECT_TYPE_VIEW = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#69
PgQuery::OBJECT_WITH_ARGS = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#70
PgQuery::OID_LIST = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#71
PgQuery::ON_CONFLICT_CLAUSE = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#72
PgQuery::PARAM_REF = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#73
PgQuery::PREPARE_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/parse_error.rb#2
class PgQuery::ParseError < ::ArgumentError
  # @return [ParseError] a new instance of ParseError
  #
  # source://pg_query//lib/pg_query/parse_error.rb#4
  def initialize(message, source_file, source_line, location); end

  # Returns the value of attribute location.
  #
  # source://pg_query//lib/pg_query/parse_error.rb#3
  def location; end
end

# source://pg_query//lib/pg_query/truncate.rb#2
class PgQuery::PossibleTruncation < ::Struct
  # Returns the value of attribute is_array
  #
  # @return [Object] the current value of is_array
  def is_array; end

  # Sets the attribute is_array
  #
  # @param value [Object] the value to set the attribute is_array to.
  # @return [Object] the newly set value
  def is_array=(_); end

  # Returns the value of attribute length
  #
  # @return [Object] the current value of length
  def length; end

  # Sets the attribute length
  #
  # @param value [Object] the value to set the attribute length to.
  # @return [Object] the newly set value
  def length=(_); end

  # Returns the value of attribute location
  #
  # @return [Object] the current value of location
  def location; end

  # Sets the attribute location
  #
  # @param value [Object] the value to set the attribute location to.
  # @return [Object] the newly set value
  def location=(_); end

  # Returns the value of attribute node_type
  #
  # @return [Object] the current value of node_type
  def node_type; end

  # Sets the attribute node_type
  #
  # @param value [Object] the value to set the attribute node_type to.
  # @return [Object] the newly set value
  def node_type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://pg_query//lib/pg_query/node_types.rb#74
PgQuery::RANGE_FUNCTION = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#75
PgQuery::RANGE_SUBSELECT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#76
PgQuery::RANGE_VAR = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#77
PgQuery::RAW_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#78
PgQuery::REFRESH_MAT_VIEW_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#106
PgQuery::RELPERSISTENCE_FIELD = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#79
PgQuery::RENAME_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#80
PgQuery::RES_TARGET = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#107
PgQuery::REXPR_FIELD = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#81
PgQuery::ROLE_SPEC = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#82
PgQuery::ROW_EXPR = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#83
PgQuery::RULE_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#84
PgQuery::SELECT_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#85
PgQuery::SET_TO_DEFAULT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#86
PgQuery::SORT_BY = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#87
PgQuery::SQL_VALUE_FUNCTION = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#108
PgQuery::STMT_FIELD = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#88
PgQuery::STRING = T.let(T.unsafe(nil), String)

# (lefthand) op ALL (SELECT ...)
#
# source://pg_query//lib/pg_query/node_types.rb#217
PgQuery::SUBLINK_TYPE_ALL = T.let(T.unsafe(nil), Integer)

# (lefthand) op ANY (SELECT ...)
#
# source://pg_query//lib/pg_query/node_types.rb#218
PgQuery::SUBLINK_TYPE_ANY = T.let(T.unsafe(nil), Integer)

# ARRAY(SELECT with single targetlist item ...)
#
# source://pg_query//lib/pg_query/node_types.rb#222
PgQuery::SUBLINK_TYPE_ARRAY = T.let(T.unsafe(nil), Integer)

# WITH query (never actually part of an expression), for SubPlans only
#
# source://pg_query//lib/pg_query/node_types.rb#223
PgQuery::SUBLINK_TYPE_CTE = T.let(T.unsafe(nil), Integer)

# EXISTS(SELECT ...)
#
# source://pg_query//lib/pg_query/node_types.rb#216
PgQuery::SUBLINK_TYPE_EXISTS = T.let(T.unsafe(nil), Integer)

# (SELECT with single targetlist item ...)
#
# source://pg_query//lib/pg_query/node_types.rb#220
PgQuery::SUBLINK_TYPE_EXPR = T.let(T.unsafe(nil), Integer)

# (SELECT with multiple targetlist items ...)
#
# source://pg_query//lib/pg_query/node_types.rb#221
PgQuery::SUBLINK_TYPE_MULTIEXPR = T.let(T.unsafe(nil), Integer)

# (lefthand) op (SELECT ...)
#
# source://pg_query//lib/pg_query/node_types.rb#219
PgQuery::SUBLINK_TYPE_ROWCOMPARE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#89
PgQuery::SUB_LINK = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#109
PgQuery::TARGET_LIST_FIELD = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#90
PgQuery::TRANSACTION_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#205
PgQuery::TRANS_STMT_BEGIN = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#207
PgQuery::TRANS_STMT_COMMIT = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#213
PgQuery::TRANS_STMT_COMMIT_PREPARED = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#212
PgQuery::TRANS_STMT_PREPARE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#210
PgQuery::TRANS_STMT_RELEASE = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#208
PgQuery::TRANS_STMT_ROLLBACK = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#214
PgQuery::TRANS_STMT_ROLLBACK_PREPARED = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#211
PgQuery::TRANS_STMT_ROLLBACK_TO = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#209
PgQuery::TRANS_STMT_SAVEPOINT = T.let(T.unsafe(nil), Integer)

# semantically identical to BEGIN
#
# source://pg_query//lib/pg_query/node_types.rb#206
PgQuery::TRANS_STMT_START = T.let(T.unsafe(nil), Integer)

# source://pg_query//lib/pg_query/node_types.rb#91
PgQuery::TRUNCATE_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#92
PgQuery::TYPE_CAST = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#93
PgQuery::TYPE_NAME = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#94
PgQuery::UPDATE_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#95
PgQuery::VACUUM_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#110
PgQuery::VALUES_LISTS_FIELD = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#96
PgQuery::VARIABLE_SET_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#97
PgQuery::VARIABLE_SHOW_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/version.rb#2
PgQuery::VERSION = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#98
PgQuery::VIEW_STMT = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#99
PgQuery::WINDOW_DEF = T.let(T.unsafe(nil), String)

# source://pg_query//lib/pg_query/node_types.rb#100
PgQuery::WITH_CLAUSE = T.let(T.unsafe(nil), String)
