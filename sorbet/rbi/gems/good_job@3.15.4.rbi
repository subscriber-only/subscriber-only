# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `good_job` gem.
# Please instead update this file by running `bin/tapioca gem good_job`.

# source://good_job//lib/active_job/queue_adapters/good_job_adapter.rb#2
module ActiveJob
  class << self
    # source://activejob/7.0.4.3/lib/active_job/gem_version.rb#5
    def gem_version; end

    # source://activejob/7.0.4.3/lib/active_job/version.rb#7
    def version; end
  end
end

# source://good_job//lib/active_job/queue_adapters/good_job_adapter.rb#3
module ActiveJob::QueueAdapters
  class << self
    # source://activejob/7.0.4.3/lib/active_job/queue_adapters.rb#136
    def lookup(name); end
  end
end

# See {GoodJob::Adapter} for details.
#
# source://good_job//lib/active_job/queue_adapters/good_job_adapter.rb#5
class ActiveJob::QueueAdapters::GoodJobAdapter < ::GoodJob::Adapter; end

# GoodJob is a multithreaded, Postgres-based, ActiveJob backend for Ruby on Rails.
#
# +GoodJob+ is the top-level namespace and exposes configuration attributes.
#
# source://good_job//lib/good_job/version.rb#2
module GoodJob
  include ::GoodJob::Dependencies
  extend ::GoodJob::Dependencies::ClassMethods

  # source://good_job//lib/good_job/dependencies.rb#9
  def _framework_ready; end

  # source://good_job//lib/good_job/dependencies.rb#9
  def _framework_ready=(val); end

  # source://good_job//lib/good_job.rb#49
  def active_record_parent_class; end

  # source://good_job//lib/good_job.rb#49
  def active_record_parent_class=(val); end

  # source://good_job//lib/good_job.rb#99
  def capsule; end

  # source://good_job//lib/good_job.rb#99
  def capsule=(val); end

  # source://good_job//lib/good_job.rb#93
  def configuration; end

  # source://good_job//lib/good_job.rb#93
  def configuration=(val); end

  # source://good_job//lib/good_job.rb#58
  def logger; end

  # source://good_job//lib/good_job.rb#58
  def logger=(val); end

  # source://good_job//lib/good_job.rb#87
  def on_thread_error; end

  # source://good_job//lib/good_job.rb#87
  def on_thread_error=(val); end

  # source://good_job//lib/good_job.rb#68
  def preserve_job_records; end

  # source://good_job//lib/good_job.rb#68
  def preserve_job_records=(val); end

  # source://good_job//lib/good_job.rb#77
  def retry_on_unhandled_error; end

  # source://good_job//lib/good_job.rb#77
  def retry_on_unhandled_error=(val); end

  class << self
    # source://good_job//lib/good_job/dependencies.rb#9
    def _framework_ready; end

    # source://good_job//lib/good_job/dependencies.rb#9
    def _framework_ready=(val); end

    # Called with exception when a GoodJob thread raises an exception
    #
    # @param exception [Exception] Exception that was raised
    # @return [void]
    #
    # source://good_job//lib/good_job.rb#104
    def _on_thread_error(exception); end

    # Sends +#shutdown+ or +#restart+ to executable objects ({GoodJob::Notifier}, {GoodJob::Poller}, {GoodJob::Scheduler}, {GoodJob::MultiScheduler}, {GoodJob::CronManager})
    #
    # @param executables [Array<Notifier, Poller, Scheduler, MultiScheduler, CronManager>] Objects to shut down.
    # @param method_name [:symbol] Method to call, e.g. +:shutdown+ or +:restart+.
    # @param timeout [nil, Numeric]
    # @return [void]
    #
    # source://good_job//lib/good_job.rb#145
    def _shutdown_all(executables, method_name = T.unsafe(nil), timeout: T.unsafe(nil)); end

    # The ActiveRecord parent class inherited by +GoodJob::Execution+ (default: +ActiveRecord::Base+).
    # Use this when using multiple databases or other custom ActiveRecord configuration.
    #
    # @example Change the base class:
    #   GoodJob.active_record_parent_class = "CustomApplicationRecord"
    # @return [ActiveRecord::Base]
    #
    # source://good_job//lib/good_job.rb#49
    def active_record_parent_class; end

    # The ActiveRecord parent class inherited by +GoodJob::Execution+ (default: +ActiveRecord::Base+).
    # Use this when using multiple databases or other custom ActiveRecord configuration.
    #
    # @example Change the base class:
    #   GoodJob.active_record_parent_class = "CustomApplicationRecord"
    # @return [ActiveRecord::Base]
    #
    # source://good_job//lib/good_job.rb#49
    def active_record_parent_class=(val); end

    # Global/default execution capsule for GoodJob.
    #
    # @return [GoodJob::Capsule, nil]
    #
    # source://good_job//lib/good_job.rb#99
    def capsule; end

    # Global/default execution capsule for GoodJob.
    #
    # @return [GoodJob::Capsule, nil]
    #
    # source://good_job//lib/good_job.rb#99
    def capsule=(val); end

    # Destroys preserved job and batch records.
    # By default, GoodJob destroys job records when the job is performed and this
    # method is not necessary. However, when `GoodJob.preserve_job_records = true`,
    # the jobs will be preserved in the database. This is useful when wanting to
    # analyze or inspect job performance.
    # If you are preserving job records this way, use this method regularly to
    # destroy old records and preserve space in your database.
    #
    # @param older_than [nil, Numeric, ActiveSupport::Duration] Jobs older than this will be destroyed (default: +86400+).
    # @return [Integer] Number of job execution records and batches that were destroyed.
    #
    # source://good_job//lib/good_job.rb#165
    def cleanup_preserved_jobs(older_than: T.unsafe(nil), in_batches_of: T.unsafe(nil)); end

    # Global configuration object for GoodJob.
    #
    # @return [GoodJob::Configuration, nil]
    #
    # source://good_job//lib/good_job.rb#93
    def configuration; end

    # Global configuration object for GoodJob.
    #
    # @return [GoodJob::Configuration, nil]
    #
    # source://good_job//lib/good_job.rb#93
    def configuration=(val); end

    # The logger used by GoodJob (default: +Rails.logger+).
    # Use this to redirect logs to a special location or file.
    #
    # @example Output GoodJob logs to a file:
    #   GoodJob.logger = ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new("log/my_logs.log"))
    # @return [Logger, nil]
    #
    # source://good_job//lib/good_job.rb#58
    def logger; end

    # The logger used by GoodJob (default: +Rails.logger+).
    # Use this to redirect logs to a special location or file.
    #
    # @example Output GoodJob logs to a file:
    #   GoodJob.logger = ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new("log/my_logs.log"))
    # @return [Logger, nil]
    #
    # source://good_job//lib/good_job.rb#58
    def logger=(val); end

    # This callable will be called when an exception reaches GoodJob (default: +nil+).
    # It can be useful for logging errors to bug tracking services, like Sentry or Airbrake.
    #
    # @example Send errors to Sentry
    #   # config/initializers/good_job.rb
    #   GoodJob.on_thread_error = -> (exception) { Raven.capture_exception(exception) }
    # @return [Proc, nil]
    #
    # source://good_job//lib/good_job.rb#87
    def on_thread_error; end

    # This callable will be called when an exception reaches GoodJob (default: +nil+).
    # It can be useful for logging errors to bug tracking services, like Sentry or Airbrake.
    #
    # @example Send errors to Sentry
    #   # config/initializers/good_job.rb
    #   GoodJob.on_thread_error = -> (exception) { Raven.capture_exception(exception) }
    # @return [Proc, nil]
    #
    # source://good_job//lib/good_job.rb#87
    def on_thread_error=(val); end

    # Perform all queued jobs in the current thread.
    # This is primarily intended for usage in a test environment.
    # Unhandled job errors will be raised.
    #
    # @param queue_string [String] Queues to execute jobs from
    # @return [void]
    #
    # source://good_job//lib/good_job.rb#215
    def perform_inline(queue_string = T.unsafe(nil)); end

    # Whether to preserve job records in the database after they have finished (default: +true+).
    # If you want to preserve jobs for latter inspection, set this to +true+.
    # If you want to preserve only jobs that finished with error for latter inspection, set this to +:on_unhandled_error+.
    # If you do not want to preserve jobs, set this to +false+.
    # When using GoodJob's cron functionality, job records will be preserved for a brief time to prevent duplicate jobs.
    #
    # @return [Boolean, Symbol, nil]
    #
    # source://good_job//lib/good_job.rb#68
    def preserve_job_records; end

    # Whether to preserve job records in the database after they have finished (default: +true+).
    # If you want to preserve jobs for latter inspection, set this to +true+.
    # If you want to preserve only jobs that finished with error for latter inspection, set this to +:on_unhandled_error+.
    # If you do not want to preserve jobs, set this to +false+.
    # When using GoodJob's cron functionality, job records will be preserved for a brief time to prevent duplicate jobs.
    #
    # @return [Boolean, Symbol, nil]
    #
    # source://good_job//lib/good_job.rb#68
    def preserve_job_records=(val); end

    # source://railties/7.0.4.3/lib/rails/engine.rb#405
    def railtie_helpers_paths; end

    # source://railties/7.0.4.3/lib/rails/engine.rb#394
    def railtie_namespace; end

    # source://railties/7.0.4.3/lib/rails/engine.rb#409
    def railtie_routes_url_helpers(include_path_helpers = T.unsafe(nil)); end

    # Stops and restarts executing jobs.
    # GoodJob does its work in pools of background threads.
    # When forking processes you should shut down these background threads before forking, and restart them after forking.
    # For example, you should use +shutdown+ and +restart+ when using async execution mode with Puma.
    # See the {file:README.md#executing-jobs-async--in-process} for more explanation and examples.
    #
    # @param timeout [Numeric] Seconds to wait for active threads to finish.
    # @return [void]
    #
    # source://good_job//lib/good_job.rb#136
    def restart(timeout: T.unsafe(nil)); end

    # Whether to re-perform a job when a type of +StandardError+ is raised to GoodJob (default: +false+).
    # If +true+, causes jobs to be re-queued and retried if they raise an instance of +StandardError+.
    # If +false+, jobs will be discarded or marked as finished if they raise an instance of +StandardError+.
    # Instances of +Exception+, like +SIGINT+, will *always* be retried, regardless of this attribute's value.
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job.rb#77
    def retry_on_unhandled_error; end

    # Whether to re-perform a job when a type of +StandardError+ is raised to GoodJob (default: +false+).
    # If +true+, causes jobs to be re-queued and retried if they raise an instance of +StandardError+.
    # If +false+, jobs will be discarded or marked as finished if they raise an instance of +StandardError+.
    # Instances of +Exception+, like +SIGINT+, will *always* be retried, regardless of this attribute's value.
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job.rb#77
    def retry_on_unhandled_error=(val); end

    # Stop executing jobs.
    # GoodJob does its work in pools of background threads.
    # When forking processes you should shut down these background threads before forking, and restart them after forking.
    # For example, you should use +shutdown+ and +restart+ when using async execution mode with Puma.
    # See the {file:README.md#executing-jobs-async--in-process} for more explanation and examples.
    #
    # @param timeout [nil, Numeric] Seconds to wait for actively executing jobs to finish
    #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
    #   * +-1+, the scheduler will wait until the shutdown is complete.
    #   * +0+, the scheduler will immediately shutdown and stop any active tasks.
    #   * +1..+, the scheduler will wait that many seconds before stopping any remaining active tasks.
    # @return [void]
    #
    # source://good_job//lib/good_job.rb#119
    def shutdown(timeout: T.unsafe(nil)); end

    # Tests whether jobs have stopped executing.
    #
    # @return [Boolean] whether background threads are shut down
    #
    # source://good_job//lib/good_job.rb#125
    def shutdown?; end

    # source://railties/7.0.4.3/lib/rails/engine.rb#397
    def table_name_prefix; end

    # source://railties/7.0.4.3/lib/rails/engine.rb#401
    def use_relative_model_naming?; end
  end
end

# source://good_job//lib/good_job/active_job_extensions/batches.rb#3
module GoodJob::ActiveJobExtensions; end

# source://good_job//lib/good_job/active_job_extensions/batches.rb#4
module GoodJob::ActiveJobExtensions::Batches
  extend ::ActiveSupport::Concern

  # source://good_job//lib/good_job/active_job_extensions/batches.rb#7
  def batch; end

  # source://good_job//lib/good_job/active_job_extensions/batches.rb#7
  def batch?; end
end

# source://good_job//lib/good_job/active_job_extensions/concurrency.rb#4
module GoodJob::ActiveJobExtensions::Concurrency
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::GoodJob::ActiveJobExtensions::Concurrency::ClassMethods

  # Generates the concurrency key from the configuration
  #
  # @raise [TypeError]
  # @return [Object] concurrency key
  #
  # source://good_job//lib/good_job/active_job_extensions/concurrency.rb#91
  def _good_job_concurrency_key; end

  # Existing or dynamically generated concurrency key
  #
  # @return [Object] concurrency key
  #
  # source://good_job//lib/good_job/active_job_extensions/concurrency.rb#85
  def good_job_concurrency_key; end

  private

  # source://good_job//lib/good_job/active_job_extensions/concurrency.rb#103
  def good_job_enqueue_concurrency_check(job, on_abort:, on_enqueue:); end

  module GeneratedClassMethods
    def good_job_concurrency_config; end
    def good_job_concurrency_config=(value); end
    def good_job_concurrency_config?; end
  end

  module GeneratedInstanceMethods; end
end

# source://good_job//lib/good_job/active_job_extensions/concurrency.rb#0
module GoodJob::ActiveJobExtensions::Concurrency::ClassMethods
  # source://good_job//lib/good_job/active_job_extensions/concurrency.rb#78
  def good_job_control_concurrency_with(config); end
end

# source://good_job//lib/good_job/active_job_extensions/concurrency.rb#9
class GoodJob::ActiveJobExtensions::Concurrency::ConcurrencyExceededError < ::StandardError
  # source://good_job//lib/good_job/active_job_extensions/concurrency.rb#10
  def backtrace; end
end

# source://good_job//lib/good_job/active_job_extensions/concurrency.rb#15
module GoodJob::ActiveJobExtensions::Concurrency::Prepends
  # source://good_job//lib/good_job/active_job_extensions/concurrency.rb#16
  def deserialize(job_data); end
end

# source://good_job//lib/good_job/active_job_extensions/concurrency.rb#7
GoodJob::ActiveJobExtensions::Concurrency::VALID_TYPES = T.let(T.unsafe(nil), Array)

# source://good_job//lib/good_job/active_job_extensions/interrupt_errors.rb#4
module GoodJob::ActiveJobExtensions::InterruptErrors
  extend ::ActiveSupport::Concern
end

# Allows configuring whether GoodJob should emit a NOTIFY event when a job is enqueued.
# Configuration will apply either globally to the Job Class, or individually to jobs
# on initial enqueue and subsequent retries.
#
# @example
#   # Include the concern to your job class:
#   class MyJob < ApplicationJob
#   include GoodJob::ActiveJobExtensions::Notify
#   self.good_job_notify = false
#   end
#
#   # Or, configure jobs individually to not notify:
#   MyJob.set(good_job_notify: false).perform_later
#
# source://good_job//lib/good_job/active_job_extensions/notify_options.rb#18
module GoodJob::ActiveJobExtensions::NotifyOptions
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods

  module GeneratedClassMethods
    def good_job_notify; end
    def good_job_notify=(value); end
  end

  module GeneratedInstanceMethods; end
end

# source://good_job//lib/good_job/active_job_extensions/notify_options.rb#21
module GoodJob::ActiveJobExtensions::NotifyOptions::Prepends
  # source://good_job//lib/good_job/active_job_extensions/notify_options.rb#34
  def deserialize(job_data); end

  # source://good_job//lib/good_job/active_job_extensions/notify_options.rb#22
  def enqueue(options = T.unsafe(nil)); end

  # source://good_job//lib/good_job/active_job_extensions/notify_options.rb#27
  def serialize; end
end

# ActiveJob Adapter.
#
# source://good_job//lib/good_job/adapter.rb#6
class GoodJob::Adapter
  # @param execution_mode [Symbol, nil] specifies how and where jobs should be executed. You can also set this with the environment variable +GOOD_JOB_EXECUTION_MODE+.
  #
  #   - +:inline+ executes jobs immediately in whatever process queued them (usually the web server process). This should only be used in test and development environments.
  #   - +:external+ causes the adapter to enqueue jobs, but not execute them. When using this option (the default for production environments), you'll need to use the command-line tool to actually execute your jobs.
  #   - +:async+ (or +:async_server+) executes jobs in separate threads within the Rails web server process (`bundle exec rails server`). It can be more economical for small workloads because you don't need a separate machine or environment for running your jobs, but if your web server is under heavy load or your jobs require a lot of resources, you should choose +:external+ instead.
  #   When not in the Rails web server, jobs will execute in +:external+ mode to ensure jobs are not executed within `rails console`, `rails db:migrate`, `rails assets:prepare`, etc.
  #   - +:async_all+ executes jobs in any Rails process.
  #
  #   The default value depends on the Rails environment:
  #
  #   - +development+: +:async:+
  #   -+test+: +:inline+
  #   - +production+ and all other environments: +:external+
  # @return [Adapter] a new instance of Adapter
  #
  # source://good_job//lib/good_job/adapter.rb#27
  def initialize(execution_mode: T.unsafe(nil), _capsule: T.unsafe(nil)); end

  # Whether the async executors are running
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/adapter.rb#207
  def async_started?; end

  # Enqueues the ActiveJob job to be performed.
  # For use by Rails; you should generally not call this directly.
  #
  # @param active_job [ActiveJob::Base] the job to be enqueued from +#perform_later+
  # @return [GoodJob::Execution]
  #
  # source://good_job//lib/good_job/adapter.rb#40
  def enqueue(active_job); end

  # Enqueues multiple ActiveJob instances at once
  #
  # @param active_jobs [Array<ActiveJob::Base>] jobs to be enqueued
  # @return [Integer] number of jobs that were successfully enqueued
  #
  # source://good_job//lib/good_job/adapter.rb#47
  def enqueue_all(active_jobs); end

  # Enqueues an ActiveJob job to be run at a specific time.
  # For use by Rails; you should generally not call this directly.
  #
  # @param active_job [ActiveJob::Base] the job to be enqueued from +#perform_later+
  # @param timestamp [Integer, nil] the epoch time to perform the job
  # @return [GoodJob::Execution]
  #
  # source://good_job//lib/good_job/adapter.rb#124
  def enqueue_at(active_job, timestamp); end

  # Whether in +:async+ execution mode.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/adapter.rb#177
  def execute_async?; end

  # Whether in +:external+ execution mode.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/adapter.rb#184
  def execute_externally?; end

  # Whether in +:inline+ execution mode.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/adapter.rb#192
  def execute_inline?; end

  # This adapter's execution mode
  #
  # @return [Symbol, nil]
  #
  # source://good_job//lib/good_job/adapter.rb#171
  def execution_mode; end

  # Shut down the thread pool executors.
  #
  # @param timeout [nil, Numeric, Symbol] Seconds to wait for active threads.
  #   * +nil+ trigger a shutdown but not wait for it to complete.
  #   * +-1+ wait until the shutdown is complete.
  #   * +0+ immediately shutdown and stop any threads.
  #   * A positive number will wait that many seconds before stopping any remaining active threads.
  # @return [void]
  #
  # source://good_job//lib/good_job/adapter.rb#164
  def shutdown(timeout: T.unsafe(nil)); end

  # Start async executors
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/adapter.rb#198
  def start_async; end

  private

  # Whether running in a web server process.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/adapter.rb#215
  def in_server_process?; end

  # @return [Boolean]
  #
  # source://good_job//lib/good_job/adapter.rb#228
  def send_notify?(active_job); end

  class << self
    # List of all instantiated Adapters in the current process.
    #
    # @return [Array<GoodJob::Adapter>, nil]
    #
    # source://good_job//lib/good_job/adapter.rb#11
    def instances; end
  end
end

class GoodJob::ApplicationController < ::ActionController::Base
  private

  # source://actionview/7.0.4.3/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  def _layout_from_proc; end
  def current_locale; end
  def default_url_options(options = T.unsafe(nil)); end
  def good_job_available_locales; end
  def switch_locale(&action); end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://actionpack/7.0.4.3/lib/abstract_controller/helpers.rb#11
    def _helper_methods; end

    # source://actionpack/7.0.4.3/lib/action_controller/metal.rb#210
    def middleware_stack; end
  end
end

module GoodJob::ApplicationController::HelperMethods
  include ::ActionText::ContentHelper
  include ::ActionText::TagHelper
  include ::Turbo::DriveHelper
  include ::Turbo::FramesHelper
  include ::Turbo::IncludesHelper
  include ::Turbo::StreamsHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::TagHelper
  include ::Turbo::Streams::ActionHelper
  include ::ActionController::Base::HelperMethods
  include ::GoodJob::ApplicationHelper

  def good_job_available_locales(*args, **_arg1, &block); end
end

module GoodJob::ApplicationHelper
  def format_duration(sec); end
  def relative_time(timestamp, **options); end
  def render_icon(name); end
  def status_badge(status); end
  def status_icon(status, **options); end
  def translate_hash(key, **options); end
  def translation_exists?(key, **options); end
end

GoodJob::ApplicationHelper::STATUS_COLOR = T.let(T.unsafe(nil), Hash)
GoodJob::ApplicationHelper::STATUS_ICONS = T.let(T.unsafe(nil), Hash)

# Extends an ActiveRecord odel to override the connection and use
# an explicit connection that has been removed from the pool.
#
# source://good_job//lib/good_job/assignable_connection.rb#5
module GoodJob::AssignableConnection
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::GoodJob::AssignableConnection::ClassMethods
end

# source://good_job//lib/good_job/assignable_connection.rb#0
module GoodJob::AssignableConnection::ClassMethods
  # source://good_job//lib/good_job/assignable_connection.rb#22
  def connection; end

  # source://good_job//lib/good_job/assignable_connection.rb#16
  def connection=(conn); end

  # source://good_job//lib/good_job/assignable_connection.rb#29
  def with_connection(conn); end
end

class GoodJob::BaseExecution < ::GoodJob::BaseRecord
  include ::GoodJob::BaseExecution::GeneratedAttributeMethods
  include ::GoodJob::BaseExecution::GeneratedAssociationMethods

  def discrete?; end
  def job_class; end

  class << self
    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators; end

    def coalesce_scheduled_at_created_at; end

    # source://activerecord/7.0.4.3/lib/active_record/enum.rb#116
    def defined_enums; end

    def discrete_support?; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def job_class(*args, **_arg1); end

    def json_string(json, attr); end
    def params_execution_count; end
    def params_job_class; end
  end
end

module GoodJob::BaseExecution::GeneratedAssociationMethods; end
module GoodJob::BaseExecution::GeneratedAttributeMethods; end

class GoodJob::BaseFilter
  def initialize(params, base_query = T.unsafe(nil)); end

  def base_query; end
  def base_query=(_arg0); end
  def filtered_count; end
  def filtered_query(filtered_params = T.unsafe(nil)); end
  def job_classes; end
  def last; end
  def params; end
  def params=(_arg0); end
  def queues; end
  def records; end
  def states; end
  def to_params(override = T.unsafe(nil)); end

  private

  def default_base_query; end
  def query_for_records; end
end

GoodJob::BaseFilter::DEFAULT_LIMIT = T.let(T.unsafe(nil), Integer)
GoodJob::BaseFilter::EMPTY = T.let(T.unsafe(nil), String)

class GoodJob::BaseRecord < ::ActiveRecord::Base
  include ::GoodJob::BaseRecord::GeneratedAttributeMethods
  include ::GoodJob::BaseRecord::GeneratedAssociationMethods

  class << self
    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators; end

    # source://activerecord/7.0.4.3/lib/active_record/enum.rb#116
    def defined_enums; end

    def migrated?; end
    def migration_pending_warning!; end
  end
end

module GoodJob::BaseRecord::GeneratedAssociationMethods; end
module GoodJob::BaseRecord::GeneratedAttributeMethods; end

class GoodJob::Batch
  include ::GlobalID::Identification

  def initialize(_record: T.unsafe(nil), **properties); end

  def _record; end
  def active_jobs; end
  def add(active_jobs = T.unsafe(nil), &block); end
  def assign_properties(properties); end
  def callback_active_jobs; end
  def callback_priority(*_arg0, **_arg1, &_arg2); end
  def callback_priority=(arg); end
  def callback_queue_name(*_arg0, **_arg1, &_arg2); end
  def callback_queue_name=(arg); end
  def created_at(*_arg0, **_arg1, &_arg2); end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#56
  def current_batch_callback_id; end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#100
  def current_batch_callback_id=(obj); end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#56
  def current_batch_id; end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#100
  def current_batch_id=(obj); end

  def description(*_arg0, **_arg1, &_arg2); end
  def description=(arg); end
  def discarded?(*_arg0, **_arg1, &_arg2); end
  def discarded_at(*_arg0, **_arg1, &_arg2); end
  def enqueue(active_jobs = T.unsafe(nil), **properties, &block); end
  def enqueued?(*_arg0, **_arg1, &_arg2); end
  def enqueued_at(*_arg0, **_arg1, &_arg2); end
  def finished?(*_arg0, **_arg1, &_arg2); end
  def finished_at(*_arg0, **_arg1, &_arg2); end
  def id(*_arg0, **_arg1, &_arg2); end
  def on_discard(*_arg0, **_arg1, &_arg2); end
  def on_discard=(arg); end
  def on_finish(*_arg0, **_arg1, &_arg2); end
  def on_finish=(arg); end
  def on_success(*_arg0, **_arg1, &_arg2); end
  def on_success=(arg); end
  def persisted?(*_arg0, **_arg1, &_arg2); end
  def properties(*_arg0, **_arg1, &_arg2); end
  def properties=(arg); end
  def reload(*_arg0, **_arg1, &_arg2); end
  def save(*_arg0, **_arg1, &_arg2); end
  def succeeded?(*_arg0, **_arg1, &_arg2); end
  def updated_at(*_arg0, **_arg1, &_arg2); end

  private

  def record; end
  def record=(_arg0); end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#48
    def current_batch_callback_id; end

    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#92
    def current_batch_callback_id=(obj); end

    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#48
    def current_batch_id; end

    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#92
    def current_batch_id=(obj); end

    def enqueue(active_jobs = T.unsafe(nil), **properties, &block); end
    def find(id); end
    def within_thread(batch_id: T.unsafe(nil), batch_callback_id: T.unsafe(nil)); end
  end
end

GoodJob::Batch::PROTECTED_PROPERTIES = T.let(T.unsafe(nil), Array)

class GoodJob::BatchRecord < ::GoodJob::BaseRecord
  include ::GoodJob::BatchRecord::GeneratedAttributeMethods
  include ::GoodJob::BatchRecord::GeneratedAssociationMethods
  include ::GoodJob::Lockable
  extend ::GoodJob::Lockable::ClassMethods

  def _continue_discard_or_finish(execution = T.unsafe(nil), lock: T.unsafe(nil)); end
  def advisory_lockable_function; end
  def advisory_lockable_function=(_arg0); end
  def advisory_lockable_function?; end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_callback_jobs(*args); end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_executions(*args); end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_jobs(*args); end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def clear_properties_change; end

  def create_with_advisory_lock; end
  def create_with_advisory_lock=(_arg0); end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def discarded?(*args, **_arg1); end

  def display_attributes; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def enqueued?(*args, **_arg1); end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def finished?(*args, **_arg1); end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties(*args, **_arg1); end

  def properties=(value); end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties?; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties_before_last_save; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties_before_type_cast; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties_came_from_user?; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties_change; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties_change_to_be_saved; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties_changed?(**options); end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties_for_database; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties_in_database; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties_previous_change; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties_previously_changed?(**options); end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties_previously_was; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties_was; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def properties_will_change!; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def restore_properties!; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def saved_change_to_discarded?; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def saved_change_to_enqueued?; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def saved_change_to_finished?; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def saved_change_to_properties; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def saved_change_to_properties?(**options); end

  def succeeded?; end
  def to_batch; end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_callback_jobs(*args); end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_executions(*args); end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_jobs(*args); end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def will_save_change_to_properties?(**options); end

  private

  def take_advisory_lock(value, &block); end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activerecord/7.0.4.3/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def advisory_lock(*args, **_arg1); end

    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def advisory_locked(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def advisory_unlocked(*args, **_arg1); end

    # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#73
    def attribute_aliases; end

    # source://activerecord/7.0.4.3/lib/active_record/attributes.rb#11
    def attributes_to_define_after_schema_loads; end

    # source://activerecord/7.0.4.3/lib/active_record/enum.rb#116
    def defined_enums; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def discarded(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def display_all(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def finished(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def includes_advisory_locks(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def joins_advisory_locks(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def not_discarded(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def owns_advisory_locked(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def succeeded(*args, **_arg1); end
  end
end

module GoodJob::BatchRecord::GeneratedAssociationMethods
  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/collection_association.rb#62
  def callback_job_ids; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/collection_association.rb#72
  def callback_job_ids=(ids); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#103
  def callback_jobs; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#111
  def callback_jobs=(value); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/collection_association.rb#62
  def execution_ids; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/collection_association.rb#72
  def execution_ids=(ids); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#103
  def executions; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#111
  def executions=(value); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/collection_association.rb#62
  def job_ids; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/collection_association.rb#72
  def job_ids=(ids); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#103
  def jobs; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#111
  def jobs=(value); end
end

module GoodJob::BatchRecord::GeneratedAttributeMethods; end

class GoodJob::BatchRecord::PropertySerializer
  class << self
    def dump(value); end
    def load(value); end
  end
end

class GoodJob::BatchesController < ::GoodJob::ApplicationController
  def index; end
  def show; end

  private

  # source://actionview/7.0.4.3/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  def _layout_from_proc; end

  class << self
    # source://actionpack/7.0.4.3/lib/action_controller/metal.rb#210
    def middleware_stack; end
  end
end

class GoodJob::BatchesFilter < ::GoodJob::BaseFilter
  def default_base_query; end
  def filtered_query(_filtered_params = T.unsafe(nil)); end
  def records; end
end

# source://good_job//lib/good_job/bulk.rb#5
module GoodJob::Bulk
  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#56
  def current_buffer; end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#100
  def current_buffer=(obj); end

  class << self
    # Capture jobs to a buffer. Pass either a block, or specific Active Jobs to be buffered.
    #
    # @param active_jobs [Array<ActiveJob::Base>] Active Jobs to be buffered.
    # @param queue_adapter Override the jobs implict queue adapter with an explicit one.
    # @raise [ArgumentError]
    # @return [nil, Array<ActiveJob::Base>] The ActiveJob instances that have been buffered; nil if no active buffer
    #
    # source://good_job//lib/good_job/bulk.rb#18
    def capture(active_jobs = T.unsafe(nil), queue_adapter: T.unsafe(nil), &block); end

    # Current buffer of jobs to be enqueued.
    #
    # @return [GoodJob::Bulk::Buffer, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#48
    def current_buffer; end

    # Current buffer of jobs to be enqueued.
    #
    # @return [GoodJob::Bulk::Buffer, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#92
    def current_buffer=(obj); end

    # Capture jobs to a buffer and enqueue them all at once; or enqueue the current buffer.
    #
    # @param active_jobs [Array<ActiveJob::Base>] Active Jobs to be enqueued.
    # @raise [ArgumentError]
    # @return [Array<ActiveJob::Base>] The ActiveJob instances that have been captured; check provider_job_id to confirm enqueued.
    #
    # source://good_job//lib/good_job/bulk.rb#33
    def enqueue(active_jobs = T.unsafe(nil), &block); end

    # Temporarily unset the current buffer; used to enqueue buffered jobs.
    #
    # @return [void]
    #
    # source://good_job//lib/good_job/bulk.rb#53
    def unbuffer; end
  end
end

# source://good_job//lib/good_job/bulk.rb#61
class GoodJob::Bulk::Buffer
  # @return [Buffer] a new instance of Buffer
  #
  # source://good_job//lib/good_job/bulk.rb#62
  def initialize; end

  # source://good_job//lib/good_job/bulk.rb#119
  def active_jobs; end

  # source://good_job//lib/good_job/bulk.rb#112
  def active_jobs_by_queue_adapter; end

  # source://good_job//lib/good_job/bulk.rb#74
  def add(active_jobs, queue_adapter: T.unsafe(nil)); end

  # source://good_job//lib/good_job/bulk.rb#66
  def capture; end

  # source://good_job//lib/good_job/bulk.rb#88
  def enqueue; end
end

# source://good_job//lib/good_job/bulk.rb#6
class GoodJob::Bulk::Error < ::StandardError; end

# Implements the +good_job+ command-line tool, which executes jobs and
# provides other utilities. The actual entry point is in +exe/good_job+, but
# it just sets up and calls this class.
#
# The +good_job+ command-line tool is based on Thor, a CLI framework for
# Ruby. For more on general usage, see http://whatisthor.com/ and
# https://github.com/erikhuda/thor/wiki.
#
# source://good_job//lib/good_job/cli.rb#14
class GoodJob::CLI < ::Thor
  # The +good_job cleanup_preserved_jobs+ command. Destroys preserved job records.
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/cli.rb#136
  def cleanup_preserved_jobs; end

  # source://good_job//lib/good_job/cli.rb#149
  def set_up_application!; end

  # The +good_job start+ command. Executes queued jobs.
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/cli.rb#91
  def start; end

  class << self
    # @return [Boolean]
    #
    # source://good_job//lib/good_job/cli.rb#31
    def exit_on_failure?; end

    # Whether to log to STDOUT
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job/cli.rb#27
    def log_to_stdout; end

    # Whether to log to STDOUT
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job/cli.rb#27
    def log_to_stdout=(_arg0); end

    # Whether to log to STDOUT
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job/cli.rb#27
    def log_to_stdout?; end

    # Whether the CLI is running from the executable
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job/cli.rb#22
    def within_exe; end

    # Whether the CLI is running from the executable
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job/cli.rb#22
    def within_exe=(_arg0); end

    # Whether the CLI is running from the executable
    #
    # @return [Boolean, nil]
    #
    # source://good_job//lib/good_job/cli.rb#22
    def within_exe?; end
  end
end

# Path to the local Rails application's environment configuration.
# Requiring this loads the application's configuration and classes.
#
# source://good_job//lib/good_job/cli.rb#17
GoodJob::CLI::RAILS_ENVIRONMENT_RB = T.let(T.unsafe(nil), String)

# A GoodJob::Capsule contains the resources necessary to execute jobs, including
# a {GoodJob::Scheduler}, {GoodJob::Poller}, {GoodJob::Notifier}, and {GoodJob::CronManager}.
# GoodJob creates a default capsule on initialization.
#
# source://good_job//lib/good_job/capsule.rb#6
class GoodJob::Capsule
  # @param configuration [GoodJob::Configuration] Configuration to use for this capsule.
  # @return [Capsule] a new instance of Capsule
  #
  # source://good_job//lib/good_job/capsule.rb#14
  def initialize(configuration: T.unsafe(nil)); end

  # Creates an execution thread(s) with the given attributes.
  #
  # @param job_state [Hash, nil] See {GoodJob::Scheduler#create_thread}.
  # @return [Boolean, nil] Whether work was started.
  #
  # source://good_job//lib/good_job/capsule.rb#80
  def create_thread(job_state = T.unsafe(nil)); end

  # Shutdown and then start the capsule again.
  #
  # @param timeout [Numeric, Symbol] Seconds to wait for active threads.
  # @raise [ArgumentError]
  # @return [void]
  #
  # source://good_job//lib/good_job/capsule.rb#60
  def restart(timeout: T.unsafe(nil)); end

  # @return [Boolean] Whether the capsule is currently running.
  #
  # source://good_job//lib/good_job/capsule.rb#68
  def running?; end

  # Shut down the thread pool executors.
  #
  # @param timeout [nil, Numeric, Symbol] Seconds to wait for active threads.
  #   * +-1+ will wait for all active threads to complete.
  #   * +0+ will interrupt active threads.
  #   * +N+ will wait at most N seconds and then interrupt active threads.
  #   * +nil+ will trigger a shutdown but not wait for it to complete.
  # @return [void]
  #
  # source://good_job//lib/good_job/capsule.rb#50
  def shutdown(timeout: T.unsafe(nil)); end

  # @return [Boolean] Whether the capsule has been shutdown.
  #
  # source://good_job//lib/good_job/capsule.rb#73
  def shutdown?; end

  # Start executing jobs (if not already running).
  #
  # source://good_job//lib/good_job/capsule.rb#24
  def start; end

  class << self
    # List of all instantiated Capsules in the current process.
    #
    # @return [Array<GoodJob::Capsule>, nil]
    #
    # source://good_job//lib/good_job/capsule.rb#11
    def instances; end
  end
end

# Tracks thresholds for cleaning up old jobs.
#
# source://good_job//lib/good_job/cleanup_tracker.rb#4
class GoodJob::CleanupTracker
  # @raise [ArgumentError]
  # @return [CleanupTracker] a new instance of CleanupTracker
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#10
  def initialize(cleanup_interval_seconds: T.unsafe(nil), cleanup_interval_jobs: T.unsafe(nil)); end

  # Whether a cleanup should be run.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#27
  def cleanup?; end

  # Returns the value of attribute cleanup_interval_jobs.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#5
  def cleanup_interval_jobs; end

  # Sets the attribute cleanup_interval_jobs
  #
  # @param value the value to set the attribute cleanup_interval_jobs to.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#5
  def cleanup_interval_jobs=(_arg0); end

  # Returns the value of attribute cleanup_interval_seconds.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#5
  def cleanup_interval_seconds; end

  # Sets the attribute cleanup_interval_seconds
  #
  # @param value the value to set the attribute cleanup_interval_seconds to.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#5
  def cleanup_interval_seconds=(_arg0); end

  # Increments job count.
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#21
  def increment; end

  # Returns the value of attribute job_count.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#5
  def job_count; end

  # Sets the attribute job_count
  #
  # @param value the value to set the attribute job_count to.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#5
  def job_count=(_arg0); end

  # Returns the value of attribute last_at.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#5
  def last_at; end

  # Sets the attribute last_at
  #
  # @param value the value to set the attribute last_at to.
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#5
  def last_at=(_arg0); end

  # Resets the counters.
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/cleanup_tracker.rb#35
  def reset; end
end

# +GoodJob::Configuration+ provides normalized configuration information to
# the rest of GoodJob. It combines environment information with explicitly
# set options to get the final values for each option.
#
# source://good_job//lib/good_job/configuration.rb#8
class GoodJob::Configuration
  # @param options [Hash] Any explicitly specified configuration options to
  #   use. Keys are symbols that match the various methods on this class.
  # @param env [Hash] A +Hash+ from which to read environment variables that
  #   might specify additional configuration values.
  # @return [Configuration] a new instance of Configuration
  #
  # source://good_job//lib/good_job/configuration.rb#79
  def initialize(options, env: T.unsafe(nil)); end

  # Whether to automatically destroy discarded jobs that have been preserved.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/configuration.rb#228
  def cleanup_discarded_jobs?; end

  # Number of jobs a {Scheduler} will execute before automatically cleaning up preserved jobs.
  # Positive values will clean up after that many jobs have run, false or 0 will disable, and -1 will clean up after every job.
  #
  # @return [Integer, nil]
  #
  # source://good_job//lib/good_job/configuration.rb#249
  def cleanup_interval_jobs; end

  # Number of seconds a {Scheduler} will wait before automatically cleaning up preserved jobs.
  # Positive values will clean up after that many jobs have run, false or 0 will disable, and -1 will clean up after every job.
  #
  # @return [Integer, nil]
  #
  # source://good_job//lib/good_job/configuration.rb#283
  def cleanup_interval_seconds; end

  # Number of seconds to preserve jobs before automatic destruction.
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/configuration.rb#237
  def cleanup_preserved_jobs_before_seconds_ago; end

  # source://good_job//lib/good_job/configuration.rb#200
  def cron; end

  # source://good_job//lib/good_job/configuration.rb#209
  def cron_entries; end

  # Tests whether to daemonize the process.
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/configuration.rb#317
  def daemonize?; end

  # Whether to run cron
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/configuration.rb#188
  def enable_cron; end

  # Whether to run cron
  #
  # @return [Boolean]
  #
  # source://good_job//lib/good_job/configuration.rb#188
  def enable_cron?; end

  # source://good_job//lib/good_job/configuration.rb#336
  def enable_listen_notify; end

  # The environment from which to read GoodJob's environment variables. By
  # default, this is the current process's environment, but it can be set
  # to something else in {#initialize}.
  #
  # @return [Hash]
  #
  # source://good_job//lib/good_job/configuration.rb#45
  def env; end

  # Specifies how and where jobs should be executed. See {Adapter#initialize}
  # for more details on possible values.
  #
  # @return [Symbol]
  #
  # source://good_job//lib/good_job/configuration.rb#91
  def execution_mode; end

  # @return [Boolean]
  #
  # source://good_job//lib/good_job/configuration.rb#157
  def inline_execution_respects_schedule?; end

  # The maximum number of future-scheduled jobs to store in memory.
  # Storing future-scheduled jobs in memory reduces execution latency
  # at the cost of increased memory usage. 10,000 stored jobs = ~20MB.
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/configuration.rb#165
  def max_cache; end

  # Indicates the number of threads to use per {Scheduler}. Note that
  # {#queue_string} may provide more specific thread counts to use with
  # individual schedulers.
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/configuration.rb#115
  def max_threads; end

  # The options that were explicitly set when initializing +Configuration+.
  # It is safe to modify this hash in place; be sure to symbolize keys.
  #
  # @return [Hash]
  #
  # source://good_job//lib/good_job/configuration.rb#39
  def options; end

  # Path of the pidfile to create when running as a daemon.
  #
  # @return [Pathname, String]
  #
  # source://good_job//lib/good_job/configuration.rb#323
  def pidfile; end

  # The number of seconds between polls for jobs. GoodJob will execute jobs
  # on queues continuously until a queue is empty, at which point it will
  # poll (using this interval) for new queued jobs to execute.
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/configuration.rb#141
  def poll_interval; end

  # Port of the probe server
  #
  # @return [nil, Integer]
  #
  # source://good_job//lib/good_job/configuration.rb#331
  def probe_port; end

  # The number of queued jobs to select when polling for a job to run.
  # This limit is intended to avoid locking a large number of rows when selecting eligible jobs
  # from the queue. This value should be higher than the total number of threads across all good_job
  # processes to ensure a thread can retrieve an eligible and unlocked job.
  #
  # @return [Integer, nil]
  #
  # source://good_job//lib/good_job/configuration.rb#218
  def queue_select_limit; end

  # Describes which queues to execute jobs from and how those queues should
  # be grouped into {Scheduler} instances. See
  # {file:README.md#optimize-queues-threads-and-processes} for more details
  # on the format of this string.
  #
  # @return [String]
  #
  # source://good_job//lib/good_job/configuration.rb#130
  def queue_string; end

  # The number of seconds to wait for jobs to finish when shutting down
  # before stopping the thread. +-1+ is forever.
  #
  # @return [Numeric]
  #
  # source://good_job//lib/good_job/configuration.rb#177
  def shutdown_timeout; end

  # source://good_job//lib/good_job/configuration.rb#344
  def smaller_number_is_higher_priority; end

  # source://good_job//lib/good_job/configuration.rb#84
  def validate!; end

  private

  # source://good_job//lib/good_job/configuration.rb#350
  def rails_config; end

  class << self
    # Returns the maximum number of threads GoodJob might consume
    #
    # @param warn [Boolean] whether to print a warning when over the limit
    # @return [Integer]
    #
    # source://good_job//lib/good_job/configuration.rb#50
    def total_estimated_threads(warn: T.unsafe(nil)); end

    # @raise [ArgumentError]
    #
    # source://good_job//lib/good_job/configuration.rb#32
    def validate_execution_mode(execution_mode); end
  end
end

# Default number of jobs to execute between preserved job cleanup runs
#
# source://good_job//lib/good_job/configuration.rb#22
GoodJob::Configuration::DEFAULT_CLEANUP_INTERVAL_JOBS = T.let(T.unsafe(nil), Integer)

# Default number of seconds to wait between preserved job cleanup runs
#
# source://good_job//lib/good_job/configuration.rb#24
GoodJob::Configuration::DEFAULT_CLEANUP_INTERVAL_SECONDS = T.let(T.unsafe(nil), Integer)

# Default number of seconds to preserve jobs for {CLI#cleanup_preserved_jobs} and {GoodJob.cleanup_preserved_jobs}
#
# source://good_job//lib/good_job/configuration.rb#20
GoodJob::Configuration::DEFAULT_CLEANUP_PRESERVED_JOBS_BEFORE_SECONDS_AGO = T.let(T.unsafe(nil), Integer)

# Default poll interval for async in development environment
#
# source://good_job//lib/good_job/configuration.rb#16
GoodJob::Configuration::DEFAULT_DEVELOPMENT_ASYNC_POLL_INTERVAL = T.let(T.unsafe(nil), Integer)

# Default to not running cron
#
# source://good_job//lib/good_job/configuration.rb#28
GoodJob::Configuration::DEFAULT_ENABLE_CRON = T.let(T.unsafe(nil), FalseClass)

# Default to enabling LISTEN/NOTIFY
#
# source://good_job//lib/good_job/configuration.rb#30
GoodJob::Configuration::DEFAULT_ENABLE_LISTEN_NOTIFY = T.let(T.unsafe(nil), TrueClass)

# Default number of threads to use per {Scheduler}
#
# source://good_job//lib/good_job/configuration.rb#18
GoodJob::Configuration::DEFAULT_MAX_CACHE = T.let(T.unsafe(nil), Integer)

# Default number of threads to use per {Scheduler}
#
# source://good_job//lib/good_job/configuration.rb#12
GoodJob::Configuration::DEFAULT_MAX_THREADS = T.let(T.unsafe(nil), Integer)

# Default number of seconds between polls for jobs
#
# source://good_job//lib/good_job/configuration.rb#14
GoodJob::Configuration::DEFAULT_POLL_INTERVAL = T.let(T.unsafe(nil), Integer)

# Default to always wait for jobs to finish for {Adapter#shutdown}
#
# source://good_job//lib/good_job/configuration.rb#26
GoodJob::Configuration::DEFAULT_SHUTDOWN_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Valid execution modes.
#
# source://good_job//lib/good_job/configuration.rb#10
GoodJob::Configuration::EXECUTION_MODES = T.let(T.unsafe(nil), Array)

class GoodJob::CronEntriesController < ::GoodJob::ApplicationController
  def disable; end
  def enable; end
  def enqueue; end
  def index; end
  def show; end

  private

  # source://actionview/7.0.4.3/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  def _layout_from_proc; end
  def check_settings_migration!; end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://actionpack/7.0.4.3/lib/action_controller/metal.rb#210
    def middleware_stack; end
  end
end

class GoodJob::CronEntry
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::API
  include ::ActiveModel::Model
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveModel::Conversion::ClassMethods

  def initialize(params = T.unsafe(nil)); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
  def __callbacks; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
  def __callbacks?; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_validate_callbacks(&block); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _validate_callbacks; end

  # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
  def _validators; end

  # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
  def _validators?; end

  def args; end
  def cron; end
  def description; end
  def disable; end
  def display_properties; end
  def enable; end
  def enabled?; end
  def enqueue(cron_at = T.unsafe(nil)); end
  def fugit; end
  def id; end
  def job_class; end
  def jobs; end
  def key; end
  def kwargs; end
  def last_at; end
  def last_job; end

  # source://activemodel/7.0.4.3/lib/active_model/naming.rb#244
  def model_name(*_arg0, **_arg1, &_arg2); end

  def next_at; end
  def params; end
  def schedule; end
  def set; end
  def to_param; end

  # source://activemodel/7.0.4.3/lib/active_model/validations.rb#48
  def validation_context; end

  private

  def args_value; end
  def display_property(value); end
  def kwargs_value; end
  def set_value; end

  # source://activemodel/7.0.4.3/lib/active_model/validations.rb#48
  def validation_context=(_arg0); end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks=(value); end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks?; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _validate_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _validate_callbacks=(value); end

    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators; end

    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators=(value); end

    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators?; end

    def all(configuration: T.unsafe(nil)); end
    def find(key, configuration: T.unsafe(nil)); end
  end
end

# CronManagers enqueue jobs on a repeating schedule.
#
# source://good_job//lib/good_job/cron_manager.rb#10
class GoodJob::CronManager
  # @param cron_entries [Array<CronEntry>]
  # @param start_on_initialize [Boolean]
  # @return [CronManager] a new instance of CronManager
  #
  # source://good_job//lib/good_job/cron_manager.rb#33
  def initialize(cron_entries = T.unsafe(nil), start_on_initialize: T.unsafe(nil)); end

  # Enqueues a scheduled task
  #
  # @param cron_entry [CronEntry] the CronEntry object to schedule
  #
  # source://good_job//lib/good_job/cron_manager.rb#84
  def create_task(cron_entry); end

  # Execution configuration to be scheduled
  #
  # @return [Hash]
  #
  # source://good_job//lib/good_job/cron_manager.rb#29
  def cron_entries; end

  # Stop and restart
  #
  # @param timeout [Numeric, nil] Unused but retained for compatibility
  #
  # source://good_job//lib/good_job/cron_manager.rb#65
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the manager is running.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/cron_manager.rb#72
  def running?; end

  # Stop/cancel any scheduled tasks
  #
  # @param timeout [Numeric, nil] Unused but retained for compatibility
  #
  # source://good_job//lib/good_job/cron_manager.rb#55
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the manager is shutdown.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/cron_manager.rb#78
  def shutdown?; end

  # Schedule tasks that will enqueue jobs based on their schedule
  #
  # source://good_job//lib/good_job/cron_manager.rb#44
  def start; end

  class << self
    # List of all instantiated CronManagers in the current process.
    #
    # @return [Array<GoodJob::CronManager>, nil]
    #
    # source://good_job//lib/good_job/cron_manager.rb#15
    def instances; end

    # Task observer for cron task
    #
    # @param time [Time]
    # @param output [Object]
    # @param thread_error [Exception]
    #
    # source://good_job//lib/good_job/cron_manager.rb#21
    def task_observer(time, output, thread_error); end
  end
end

# Thread-local attributes for passing values from Instrumentation.
# (Cannot use ActiveSupport::CurrentAttributes because ActiveJob resets it)
#
# source://good_job//lib/good_job/current_thread.rb#7
module GoodJob::CurrentThread
  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#56
  def cron_at; end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#100
  def cron_at=(obj); end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#56
  def cron_key; end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#100
  def cron_key=(obj); end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#56
  def error_on_discard; end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#100
  def error_on_discard=(obj); end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#56
  def error_on_retry; end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#100
  def error_on_retry=(obj); end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#56
  def execution; end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#100
  def execution=(obj); end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#56
  def execution_interrupted; end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#100
  def execution_interrupted=(obj); end

  class << self
    # @return [String] UUID of the currently executing GoodJob::Execution
    #
    # source://good_job//lib/good_job/current_thread.rb#72
    def active_job_id; end

    # Cron At
    #
    # @return [DateTime, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#48
    def cron_at; end

    # Cron At
    #
    # @return [DateTime, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#92
    def cron_at=(obj); end

    # Cron Key
    #
    # @return [String, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#48
    def cron_key; end

    # Cron Key
    #
    # @return [String, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#92
    def cron_key=(obj); end

    # Error captured by discard_on
    #
    # @return [Exception, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#48
    def error_on_discard; end

    # Error captured by discard_on
    #
    # @return [Exception, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#92
    def error_on_discard=(obj); end

    # Error captured by retry_on
    #
    # @return [Exception, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#48
    def error_on_retry; end

    # Error captured by retry_on
    #
    # @return [Exception, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#92
    def error_on_retry=(obj); end

    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#48
    def execution; end

    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#92
    def execution=(obj); end

    # Execution Interrupted
    #
    # @return [Boolean, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#48
    def execution_interrupted; end

    # Execution Interrupted
    #
    # @return [Boolean, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#92
    def execution_interrupted=(obj); end

    # @return [Integer] Current process ID
    #
    # source://good_job//lib/good_job/current_thread.rb#77
    def process_id; end

    # Resets attributes
    #
    # @param values [Hash] to assign
    # @return [void]
    #
    # source://good_job//lib/good_job/current_thread.rb#57
    def reset(values = T.unsafe(nil)); end

    # @return [String] Current thread name
    #
    # source://good_job//lib/good_job/current_thread.rb#82
    def thread_name; end

    # Exports values to hash
    #
    # @return [Hash]
    #
    # source://good_job//lib/good_job/current_thread.rb#65
    def to_h; end

    # Wrap the yielded block with CurrentThread values and reset after the block
    #
    # @return [void]
    # @yield [self]
    #
    # source://good_job//lib/good_job/current_thread.rb#89
    def within; end
  end
end

# Resettable accessors for thread-local values.
#
# source://good_job//lib/good_job/current_thread.rb#9
GoodJob::CurrentThread::ACCESSORS = T.let(T.unsafe(nil), Array)

# source://good_job//lib/good_job.rb#40
GoodJob::DEFAULT_LOGGER = T.let(T.unsafe(nil), ActiveSupport::Logger)

# Manages daemonization of the current process.
#
# source://good_job//lib/good_job/daemon.rb#6
class GoodJob::Daemon
  # @param pidfile [Pathname, String] Pidfile path
  # @return [Daemon] a new instance of Daemon
  #
  # source://good_job//lib/good_job/daemon.rb#12
  def initialize(pidfile:); end

  # Daemonizes the current process and writes out a pidfile.
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/daemon.rb#18
  def daemonize; end

  # The path of the generated pidfile.
  #
  # @return [Pathname, String]
  #
  # source://good_job//lib/good_job/daemon.rb#9
  def pidfile; end

  private

  # @return [void]
  #
  # source://good_job//lib/good_job/daemon.rb#41
  def check_pid; end

  # @return [void]
  #
  # source://good_job//lib/good_job/daemon.rb#36
  def delete_pid; end

  # @param pidfile [Pathname, String]
  # @return [Symbol]
  #
  # source://good_job//lib/good_job/daemon.rb#52
  def pid_status(pidfile); end

  # @return [void]
  #
  # source://good_job//lib/good_job/daemon.rb#27
  def write_pid; end
end

# Extends GoodJob module to track Rails boot dependencies.
#
# source://good_job//lib/good_job/dependencies.rb#5
module GoodJob::Dependencies
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::GoodJob::Dependencies::ClassMethods
end

# source://good_job//lib/good_job/dependencies.rb#0
module GoodJob::Dependencies::ClassMethods
  # source://good_job//lib/good_job/dependencies.rb#18
  def _start_async_adapters; end

  # source://good_job//lib/good_job/dependencies.rb#14
  def async_ready?; end
end

class GoodJob::DiscreteExecution < ::GoodJob::BaseRecord
  include ::GoodJob::DiscreteExecution::GeneratedAttributeMethods
  include ::GoodJob::DiscreteExecution::GeneratedAssociationMethods

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_execution(*args); end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_job(*args); end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def clear_performed_at_change; end

  def display_serialized_params; end
  def last_status_at; end
  def number; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at(*args, **_arg1); end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at=(value); end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at?; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at_before_last_save; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at_before_type_cast; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at_came_from_user?; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at_change; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at_change_to_be_saved; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at_changed?(**options); end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at_for_database; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at_in_database; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at_previous_change; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at_previously_changed?(**options); end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at_previously_was; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at_was; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def performed_at_will_change!; end

  def queue_latency; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def restore_performed_at!; end

  def runtime_latency; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def saved_change_to_performed_at; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def saved_change_to_performed_at?(**options); end

  def status; end

  # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#211
  def will_save_change_to_performed_at?(**options); end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activerecord/7.0.4.3/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators; end

    # source://activemodel/7.0.4.3/lib/active_model/attribute_methods.rb#73
    def attribute_aliases; end

    # source://activerecord/7.0.4.3/lib/active_record/enum.rb#116
    def defined_enums; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def finished(*args, **_arg1); end
  end
end

module GoodJob::DiscreteExecution::GeneratedAssociationMethods
  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#28
  def build_execution(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#28
  def build_job(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#32
  def create_execution(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#36
  def create_execution!(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#32
  def create_job(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#36
  def create_job!(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#103
  def execution; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#111
  def execution=(value); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/belongs_to.rb#132
  def execution_changed?; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/belongs_to.rb#136
  def execution_previously_changed?; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#103
  def job; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#111
  def job=(value); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/belongs_to.rb#132
  def job_changed?; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/belongs_to.rb#136
  def job_previously_changed?; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#19
  def reload_execution; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#19
  def reload_job; end
end

module GoodJob::DiscreteExecution::GeneratedAttributeMethods; end

# Ruby on Rails integration.
#
# source://good_job//lib/good_job/engine.rb#4
class GoodJob::Engine < ::Rails::Engine
  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end
  end
end

class GoodJob::Execution < ::GoodJob::BaseExecution
  include ::GoodJob::Execution::GeneratedAttributeMethods
  include ::GoodJob::Execution::GeneratedAssociationMethods
  include ::GoodJob::Lockable
  include ::GoodJob::Filterable
  include ::GoodJob::Reportable
  extend ::GoodJob::Lockable::ClassMethods
  extend ::GoodJob::Filterable::ClassMethods

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _perform_callbacks; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _perform_unlocked_callbacks; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_perform_callbacks(&block); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_perform_unlocked_callbacks(&block); end

  def active_job(ignore_deserialization_errors: T.unsafe(nil)); end
  def advisory_lockable_function; end
  def advisory_lockable_function=(_arg0); end
  def advisory_lockable_function?; end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_batch(*args); end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_discrete_executions(*args); end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_job(*args); end

  def create_with_advisory_lock; end
  def create_with_advisory_lock=(_arg0); end
  def destroy_job; end
  def display_serialized_params; end
  def executable?; end
  def make_discrete; end
  def number; end
  def perform; end
  def queue_latency; end
  def running?; end
  def runtime_latency; end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_discrete_executions(*args); end

  private

  def active_job_data; end
  def continue_discard_or_finish_batch; end
  def reset_batch_values(&block); end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _perform_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _perform_callbacks=(value); end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _perform_unlocked_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _perform_unlocked_callbacks=(value); end

    # source://activerecord/7.0.4.3/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def active_job_id(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def advisory_lock(*args, **_arg1); end

    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def advisory_locked(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def advisory_unlocked(*args, **_arg1); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#144
    def after_perform(*args, **options, &block); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#144
    def after_perform_unlocked(*args, **options, &block); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#137
    def around_perform(*args, **options, &block); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#130
    def before_perform(*args, **options, &block); end

    def build_for_enqueue(active_job, overrides = T.unsafe(nil)); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def creation_ordered(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def dead(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/enum.rb#116
    def defined_enums; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def dequeueing_ordered(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def display_all(*args, **_arg1); end

    def enqueue(active_job, scheduled_at: T.unsafe(nil), create_with_advisory_lock: T.unsafe(nil)); end
    def enqueue_args(active_job, overrides = T.unsafe(nil)); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def finished(*args, **_arg1); end

    def format_error(error); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def head(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def includes_advisory_locks(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def joins_advisory_locks(*args, **_arg1); end

    def next_scheduled_at(after: T.unsafe(nil), limit: T.unsafe(nil), now_limit: T.unsafe(nil)); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def only_scheduled(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def owns_advisory_locked(*args, **_arg1); end

    def perform_with_advisory_lock(parsed_queues: T.unsafe(nil), queue_select_limit: T.unsafe(nil)); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def priority_ordered(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def queue_ordered(*args, **_arg1); end

    def queue_parser(string); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def queue_string(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def running(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def schedule_ordered(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def search_text(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def unfinished(*args, **_arg1); end
  end
end

GoodJob::Execution::DEFAULT_PRIORITY = T.let(T.unsafe(nil), Integer)
GoodJob::Execution::DEFAULT_QUEUE_NAME = T.let(T.unsafe(nil), String)
GoodJob::Execution::ERROR_MESSAGE_SEPARATOR = T.let(T.unsafe(nil), String)

module GoodJob::Execution::GeneratedAssociationMethods
  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#103
  def batch; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#111
  def batch=(value); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/belongs_to.rb#132
  def batch_changed?; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/belongs_to.rb#136
  def batch_previously_changed?; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#28
  def build_batch(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#28
  def build_job(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#32
  def create_batch(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#36
  def create_batch!(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#32
  def create_job(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#36
  def create_job!(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/collection_association.rb#62
  def discrete_execution_ids; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/collection_association.rb#72
  def discrete_execution_ids=(ids); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#103
  def discrete_executions; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#111
  def discrete_executions=(value); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#103
  def job; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#111
  def job=(value); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/belongs_to.rb#132
  def job_changed?; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/belongs_to.rb#136
  def job_previously_changed?; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#19
  def reload_batch; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#19
  def reload_job; end
end

module GoodJob::Execution::GeneratedAttributeMethods; end
class GoodJob::Execution::PreviouslyPerformedError < ::StandardError; end

class GoodJob::ExecutionResult
  def initialize(value:, handled_error: T.unsafe(nil), unhandled_error: T.unsafe(nil), retried: T.unsafe(nil)); end

  def handled_error; end
  def retried; end
  def retried?; end
  def unhandled_error; end
  def value; end
end

module GoodJob::Filterable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::GoodJob::Filterable::ClassMethods
end

module GoodJob::Filterable::ClassMethods
  def database_supports_websearch_to_tsquery?; end
end

class GoodJob::FrontendsController < ::ActionController::Base
  def module; end
  def static; end

  private

  # source://actionview/7.0.4.3/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  def _layout_from_proc; end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end

    def js_modules; end

    # source://actionpack/7.0.4.3/lib/action_controller/metal.rb#210
    def middleware_stack; end
  end
end

GoodJob::FrontendsController::MODULE_OVERRIDES = T.let(T.unsafe(nil), Hash)
GoodJob::FrontendsController::STATIC_ASSETS = T.let(T.unsafe(nil), Hash)

# Exception raised when a job is interrupted by a SIGKILL or power failure.
#
# source://good_job//lib/good_job/interrupt_error.rb#4
class GoodJob::InterruptError < ::StandardError; end

class GoodJob::Job < ::GoodJob::BaseExecution
  include ::GoodJob::Job::GeneratedAttributeMethods
  include ::GoodJob::Job::GeneratedAssociationMethods
  include ::GoodJob::Filterable
  include ::GoodJob::Lockable
  include ::GoodJob::Reportable
  extend ::GoodJob::Filterable::ClassMethods
  extend ::GoodJob::Lockable::ClassMethods

  def _execution_id; end
  def _head?; end
  def advisory_lockable_function; end
  def advisory_lockable_function=(_arg0); end
  def advisory_lockable_function?; end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_batch(*args); end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_discrete_executions(*args); end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def autosave_associated_records_for_executions(*args); end

  def create_with_advisory_lock; end
  def create_with_advisory_lock=(_arg0); end
  def destroy_job; end
  def discard_job(message); end
  def discarded?; end
  def display_error; end
  def display_serialized_params; end
  def executions_count; end
  def finished?; end
  def head_execution(reload: T.unsafe(nil)); end
  def id; end
  def preserved_executions_count; end
  def recent_error; end
  def reload(options = T.unsafe(nil)); end
  def reschedule_job(scheduled_at = T.unsafe(nil)); end
  def retry_job; end
  def running?; end
  def succeeded?; end
  def tail_execution; end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_discrete_executions(*args); end

  # source://activerecord/7.0.4.3/lib/active_record/autosave_association.rb#160
  def validate_associated_records_for_executions(*args); end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activerecord/7.0.4.3/lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def advisory_lock(*args, **_arg1); end

    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def advisory_locked(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def advisory_unlocked(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/default.rb#19
    def default_scopes; end

    # source://activerecord/7.0.4.3/lib/active_record/enum.rb#116
    def defined_enums; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def discarded(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def display_all(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def finished(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def finished_before(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def includes_advisory_locks(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def joins_advisory_locks(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def owns_advisory_locked(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def queued(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def retried(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def running(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def scheduled(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def search_text(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def succeeded(*args, **_arg1); end

    def table_name(*_arg0, **_arg1, &_arg2); end
    def table_name=(_value); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def unfinished_undiscrete(*args, **_arg1); end
  end
end

class GoodJob::Job::ActionForStateMismatchError < ::StandardError; end
class GoodJob::Job::AdapterNotGoodJobError < ::StandardError; end
class GoodJob::Job::DiscardJobError < ::StandardError; end

module GoodJob::Job::GeneratedAssociationMethods
  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#103
  def batch; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#111
  def batch=(value); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/belongs_to.rb#132
  def batch_changed?; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/belongs_to.rb#136
  def batch_previously_changed?; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#28
  def build_batch(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#32
  def create_batch(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#36
  def create_batch!(*args, &block); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/collection_association.rb#62
  def discrete_execution_ids; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/collection_association.rb#72
  def discrete_execution_ids=(ids); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#103
  def discrete_executions; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#111
  def discrete_executions=(value); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/collection_association.rb#62
  def execution_ids; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/collection_association.rb#72
  def execution_ids=(ids); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#103
  def executions; end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/association.rb#111
  def executions=(value); end

  # source://activerecord/7.0.4.3/lib/active_record/associations/builder/singular_association.rb#19
  def reload_batch; end
end

module GoodJob::Job::GeneratedAttributeMethods; end

# JobPerformer queries the database for jobs and performs them on behalf of a
# {Scheduler}. It mainly functions as glue between a {Scheduler} and the jobs
# it should be executing.
#
# The JobPerformer must be safe to execute across multiple threads.
#
# source://good_job//lib/good_job/job_performer.rb#12
class GoodJob::JobPerformer
  # @param queue_string [String] Queues to execute jobs from
  # @return [JobPerformer] a new instance of JobPerformer
  #
  # source://good_job//lib/good_job/job_performer.rb#16
  def initialize(queue_string); end

  # Destroy expired preserved jobs
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/job_performer.rb#70
  def cleanup; end

  # A meaningful name to identify the performer in logs and for debugging.
  #
  # @return [String] The queues from which Jobs are worked
  #
  # source://good_job//lib/good_job/job_performer.rb#22
  def name; end

  # Perform the next eligible job
  #
  # @return [Object, nil] Returns job result or +nil+ if no job was found
  #
  # source://good_job//lib/good_job/job_performer.rb#28
  def next; end

  # Tests whether this performer should be used in GoodJob's current state.
  #
  # For example, state will be a LISTEN/NOTIFY message that is passed down
  # from the Notifier to the Scheduler. The Scheduler is able to ask
  # its performer "does this message relate to you?", and if not, ignore it
  # to minimize thread wake-ups, database queries, and thundering herds.
  #
  # @return [Boolean] whether the performer's {#next} method should be
  #   called in the current state.
  #
  # source://good_job//lib/good_job/job_performer.rb#47
  def next?(state = T.unsafe(nil)); end

  # The Returns timestamps of when next tasks may be available.
  #
  # @param after [DateTime, Time, nil] future jobs scheduled after this time
  # @param limit [Integer] number of future timestamps to return
  # @param now_limit [Integer] number of past timestamps to return
  # @return [Array<DateTime, Time>, nil]
  #
  # source://good_job//lib/good_job/job_performer.rb#64
  def next_at(after: T.unsafe(nil), limit: T.unsafe(nil), now_limit: T.unsafe(nil)); end

  # source://good_job//lib/good_job/job_performer.rb#13
  def performing_active_job_ids; end

  # source://good_job//lib/good_job/job_performer.rb#13
  def performing_active_job_ids=(val); end

  private

  # source://good_job//lib/good_job/job_performer.rb#78
  def job_query; end

  # source://good_job//lib/good_job/job_performer.rb#82
  def parsed_queues; end

  # Returns the value of attribute queue_string.
  #
  # source://good_job//lib/good_job/job_performer.rb#76
  def queue_string; end

  class << self
    # source://good_job//lib/good_job/job_performer.rb#13
    def performing_active_job_ids; end

    # source://good_job//lib/good_job/job_performer.rb#13
    def performing_active_job_ids=(val); end
  end
end

class GoodJob::JobsController < ::GoodJob::ApplicationController
  def destroy; end
  def discard; end
  def index; end
  def mass_update; end
  def reschedule; end
  def retry; end
  def show; end

  private

  # source://actionview/7.0.4.3/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  def _layout_from_proc; end
  def redirect_on_error(exception); end

  class << self
    # source://actionpack/7.0.4.3/lib/action_controller/metal.rb#210
    def middleware_stack; end

    # source://activesupport/7.0.4.3/lib/active_support/rescuable.rb#13
    def rescue_handlers; end
  end
end

GoodJob::JobsController::ACTIONS = T.let(T.unsafe(nil), Hash)
GoodJob::JobsController::DISCARD_MESSAGE = T.let(T.unsafe(nil), String)

class GoodJob::JobsFilter < ::GoodJob::BaseFilter
  def filtered_count; end
  def filtered_query(filter_params = T.unsafe(nil)); end
  def states; end

  private

  def default_base_query; end
  def query_for_records; end
end

module GoodJob::Lockable
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::GoodJob::Lockable::ClassMethods

  def advisory_lock(key: T.unsafe(nil), function: T.unsafe(nil)); end
  def advisory_lock!(key: T.unsafe(nil), function: T.unsafe(nil)); end
  def advisory_locked?(key: T.unsafe(nil)); end
  def advisory_unlock(key: T.unsafe(nil), function: T.unsafe(nil)); end
  def advisory_unlock!(key: T.unsafe(nil), function: T.unsafe(nil)); end
  def advisory_unlocked?(key: T.unsafe(nil)); end
  def lockable_column_key(column: T.unsafe(nil)); end
  def lockable_key; end
  def owns_advisory_lock?(key: T.unsafe(nil)); end
  def pg_or_jdbc_query(*_arg0, **_arg1, &_arg2); end
  def with_advisory_lock(key: T.unsafe(nil), function: T.unsafe(nil)); end

  module GeneratedClassMethods
    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
  end

  module GeneratedInstanceMethods
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end
  end
end

module GoodJob::Lockable::ClassMethods
  def _advisory_lockable_column; end
  def advisory_lock_key(key, function: T.unsafe(nil)); end
  def advisory_unlock_key(key, function: T.unsafe(nil)); end
  def advisory_unlock_session; end
  def advisory_unlockable_function(function = T.unsafe(nil)); end
  def pg_or_jdbc_query(query); end
  def supports_cte_materialization_specifiers?; end
  def with_advisory_lock(column: T.unsafe(nil), function: T.unsafe(nil), unlock_session: T.unsafe(nil), select_limit: T.unsafe(nil)); end
end

class GoodJob::Lockable::RecordAlreadyAdvisoryLockedError < ::StandardError; end

# Listens to GoodJob notifications and logs them.
#
# Each method corresponds to the name of a notification. For example, when
# the {Scheduler} shuts down, it sends a notification named
# +"scheduler_shutdown.good_job"+ and the {#scheduler_shutdown} method will
# be called here. See the
# {https://api.rubyonrails.org/classes/ActiveSupport/LogSubscriber.html ActiveSupport::LogSubscriber}
# documentation for more.
#
# source://good_job//lib/good_job/log_subscriber.rb#13
class GoodJob::LogSubscriber < ::ActiveSupport::LogSubscriber
  # Responds to the +cleanup_preserved_jobs.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#154
  def cleanup_preserved_jobs(event); end

  # Responds to the +create.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#20
  def create(event); end

  # Responds to the +cron_manager_start.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#61
  def cron_manager_start(event); end

  # source://good_job//lib/good_job/log_subscriber.rb#246
  def debug(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # source://good_job//lib/good_job/log_subscriber.rb#246
  def error(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # source://good_job//lib/good_job/log_subscriber.rb#246
  def fatal(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # Responds to the +finished_job_task.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#40
  def finished_job_task(event); end

  # Responds to the +finished_timer_task.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#30
  def finished_timer_task(event); end

  # source://good_job//lib/good_job/log_subscriber.rb#246
  def info(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # Get the logger associated with this {LogSubscriber} instance.
  #
  # @return [Logger]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#167
  def logger; end

  # Responds to the +notifier_listen.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#122
  def notifier_listen(event); end

  # Responds to the +notifier_notified.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#129
  def notifier_notified(event); end

  # Responds to the +notifier_notify_error.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#138
  def notifier_notify_error(event); end

  # Responds to the +notifier_unlisten.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#147
  def notifier_unlisten(event); end

  # Responds to the +perform_job.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#111
  def perform_job(event); end

  # Responds to the +scheduler_create_pool.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#50
  def scheduler_create_pool(event); end

  # Responds to the +scheduler_restart_pools.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#102
  def scheduler_restart_pools(event); end

  # Responds to the +scheduler_shutdown.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#80
  def scheduler_shutdown(event); end

  # source://good_job//lib/good_job/log_subscriber.rb#88
  def scheduler_shutdown_kill(event); end

  # Responds to the +scheduler_shutdown_start.good_job+ notification.
  #
  # @param event [ActiveSupport::Notifications::Event]
  # @return [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#71
  def scheduler_shutdown_start(event); end

  # source://good_job//lib/good_job/log_subscriber.rb#246
  def unknown(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  # source://good_job//lib/good_job/log_subscriber.rb#246
  def warn(progname = T.unsafe(nil), tags: T.unsafe(nil), &block); end

  private

  # Add "GoodJob" plus any specified tags to every
  # {ActiveSupport::TaggedLogging} logger in {LogSubscriber.loggers}. Tags
  # are only applicable inside the block passed to this method.
  #
  # @return [void]
  # @yield [void]
  #
  # source://good_job//lib/good_job/log_subscriber.rb#217
  def tag_logger(*tags, &block); end

  class << self
    # Represents all the loggers attached to {LogSubscriber} with a single
    # logging interface. Writing to this logger is a shortcut for writing to
    # each of the loggers in {LogSubscriber.loggers}.
    #
    # @return [Logger]
    #
    # source://good_job//lib/good_job/log_subscriber.rb#191
    def logger; end

    # Tracks all loggers that {LogSubscriber} is writing to. You can write to
    # multiple logs by appending to this array. After updating it, you should
    # usually call {LogSubscriber.reset_logger} to make sure they are all
    # written to.
    #
    # Defaults to {GoodJob.logger}.
    #
    # @example Write to STDOUT and to a file:
    #   GoodJob::LogSubscriber.loggers << ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new(STDOUT))
    #   GoodJob::LogSubscriber.loggers << ActiveSupport::TaggedLogging.new(ActiveSupport::Logger.new("log/my_logs.log"))
    #   GoodJob::LogSubscriber.reset_logger
    # @return [Array<Logger>]
    #
    # source://good_job//lib/good_job/log_subscriber.rb#183
    def loggers; end

    # Reset {LogSubscriber.logger} and force it to rebuild a new shortcut to
    # all the loggers in {LogSubscriber.loggers}. You should usually call
    # this after modifying the {LogSubscriber.loggers} array.
    #
    # @return [void]
    #
    # source://good_job//lib/good_job/log_subscriber.rb#205
    def reset_logger; end
  end
end

# Delegates the interface of a single {Scheduler} to multiple Schedulers.
#
# source://good_job//lib/good_job/multi_scheduler.rb#4
class GoodJob::MultiScheduler
  # @param schedulers [Array<Scheduler>]
  # @return [MultiScheduler] a new instance of MultiScheduler
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#9
  def initialize(schedulers); end

  # Delegates to {Scheduler#create_thread}.
  #
  # @param state [Hash]
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#42
  def create_thread(state = T.unsafe(nil)); end

  # Delegates to {Scheduler#restart}.
  #
  # @param timeout [Numeric, nil]
  # @return [void]
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#35
  def restart(timeout: T.unsafe(nil)); end

  # Delegates to {Scheduler#running?}.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#15
  def running?; end

  # @return [Array<Scheduler>] List of the scheduler delegates
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#6
  def schedulers; end

  # Delegates to {Scheduler#shutdown}.
  #
  # @param timeout [Numeric, nil]
  # @return [void]
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#28
  def shutdown(timeout: T.unsafe(nil)); end

  # Delegates to {Scheduler#shutdown?}.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/multi_scheduler.rb#21
  def shutdown?; end
end

# Notifiers hook into Postgres LISTEN/NOTIFY functionality to emit and listen for notifications across processes.
#
# Notifiers can emit NOTIFY messages through Postgres.
# A notifier will LISTEN for messages by creating a background thread that runs in an instance of +Concurrent::ThreadPoolExecutor+.
# When a message is received, the notifier passes the message to each of its recipients.
#
# source://good_job//lib/good_job/notifier/process_registration.rb#4
class GoodJob::Notifier
  include ::ActiveSupport::Callbacks
  include ::GoodJob::Notifier::ProcessRegistration
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # @param recipients [Array<#call, Array(Object, Symbol)>]
  # @param enable_listening [true, false]
  # @return [Notifier] a new instance of Notifier
  #
  # source://good_job//lib/good_job/notifier.rb#72
  def initialize(*recipients, enable_listening: T.unsafe(nil)); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
  def __callbacks; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
  def __callbacks?; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _listen_callbacks; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_listen_callbacks(&block); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_unlisten_callbacks(&block); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _unlisten_callbacks; end

  # Tests whether the notifier is active and has acquired a dedicated database connection.
  #
  # @return [true, false, nil]
  #
  # source://good_job//lib/good_job/notifier.rb#88
  def connected?; end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#56
  def connection; end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#100
  def connection=(obj); end

  # Invoked on completion of ThreadPoolExecutor task
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/notifier.rb#141
  def listen_observer(_time, _result, thread_error); end

  # Tests whether the notifier is listening for new messages.
  #
  # @return [true, false, nil]
  #
  # source://good_job//lib/good_job/notifier.rb#94
  def listening?; end

  # List of recipients that will receive notifications.
  #
  # @return [Array<#call, Array(Object, Symbol)>]
  #
  # source://good_job//lib/good_job/notifier.rb#68
  def recipients; end

  # Restart the notifier.
  # When shutdown, start; or shutdown and start.
  #
  # @param timeout [nil, Numeric] Seconds to wait; shares same values as {#shutdown}.
  # @return [void]
  #
  # source://good_job//lib/good_job/notifier.rb#132
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the notifier is running.
  #
  # @return [true, false, nil]
  #
  # source://good_job//lib/good_job/notifier.rb#101
  def running?(*_arg0, **_arg1, &_arg2); end

  # Shut down the notifier.
  # This stops the background LISTENing thread.
  # Use {#shutdown?} to determine whether threads have stopped.
  #
  # @param timeout [Numeric, nil] Seconds to wait for active threads.
  #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
  #   * +-1+, the scheduler will wait until the shutdown is complete.
  #   * +0+, the scheduler will immediately shutdown and stop any threads.
  #   * A positive number will wait that many seconds before stopping any remaining active threads.
  # @return [void]
  #
  # source://good_job//lib/good_job/notifier.rb#117
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the scheduler is shutdown.
  #
  # @return [true, false, nil]
  #
  # source://good_job//lib/good_job/notifier.rb#106
  def shutdown?(*_arg0, **_arg1, &_arg2); end

  private

  # source://good_job//lib/good_job/notifier.rb#172
  def create_executor; end

  # Returns the value of attribute executor.
  #
  # source://good_job//lib/good_job/notifier.rb#170
  def executor; end

  # source://good_job//lib/good_job/notifier.rb#176
  def listen(delay: T.unsafe(nil)); end

  # source://good_job//lib/good_job/notifier.rb#260
  def reset_connection_errors; end

  # source://good_job//lib/good_job/notifier.rb#240
  def wait_for_notify; end

  # source://good_job//lib/good_job/notifier.rb#224
  def with_connection; end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks=(value); end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks?; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _listen_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _listen_callbacks=(value); end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _unlisten_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _unlisten_callbacks=(value); end

    # ActiveRecord Connection that has been established for the Notifier.
    #
    # @return [ActiveRecord::ConnectionAdapters::AbstractAdapter, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#48
    def connection; end

    # ActiveRecord Connection that has been established for the Notifier.
    #
    # @return [ActiveRecord::ConnectionAdapters::AbstractAdapter, nil]
    #
    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#92
    def connection=(obj); end

    # List of all instantiated Notifiers in the current process.
    #
    # @return [Array<GoodJob::Notifier>, nil]
    #
    # source://good_job//lib/good_job/notifier.rb#49
    def instances; end

    # Send a message via Postgres NOTIFY
    #
    # @param message [#to_json]
    #
    # source://good_job//lib/good_job/notifier.rb#59
    def notify(message); end
  end
end

# Default Postgres channel for LISTEN/NOTIFY
#
# source://good_job//lib/good_job/notifier.rb#21
GoodJob::Notifier::CHANNEL = T.let(T.unsafe(nil), String)

# Connection errors that will wait {RECONNECT_INTERVAL} before reconnecting
#
# source://good_job//lib/good_job/notifier.rb#37
GoodJob::Notifier::CONNECTION_ERRORS = T.let(T.unsafe(nil), Array)

# source://good_job//lib/good_job/notifier.rb#43
GoodJob::Notifier::CONNECTION_ERRORS_REPORTING_THRESHOLD = T.let(T.unsafe(nil), Integer)

# Defaults for instance of Concurrent::ThreadPoolExecutor
#
# source://good_job//lib/good_job/notifier.rb#23
GoodJob::Notifier::EXECUTOR_OPTIONS = T.let(T.unsafe(nil), Hash)

# Extends the Notifier to register the process in the database.
#
# source://good_job//lib/good_job/notifier/process_registration.rb#6
module GoodJob::Notifier::ProcessRegistration
  extend ::ActiveSupport::Concern

  # Deregisters the current process.
  #
  # source://good_job//lib/good_job/notifier/process_registration.rb#23
  def deregister_process; end

  # Registers the current process.
  #
  # source://good_job//lib/good_job/notifier/process_registration.rb#15
  def register_process; end
end

# Seconds to wait if database cannot be connected to
#
# source://good_job//lib/good_job/notifier.rb#35
GoodJob::Notifier::RECONNECT_INTERVAL = T.let(T.unsafe(nil), Integer)

# Seconds to block while LISTENing for a message
#
# source://good_job//lib/good_job/notifier.rb#33
GoodJob::Notifier::WAIT_INTERVAL = T.let(T.unsafe(nil), Integer)

# Pollers regularly wake up execution threads to check for new work.
#
# source://good_job//lib/good_job/poller.rb#8
class GoodJob::Poller
  # @param recipients [Array<Proc, #call, Array(Object, Symbol)>]
  # @param poll_interval [Integer, nil] number of seconds between polls
  # @return [Poller] a new instance of Poller
  #
  # source://good_job//lib/good_job/poller.rb#35
  def initialize(*recipients, poll_interval: T.unsafe(nil)); end

  # List of recipients that will receive notifications.
  #
  # @return [Array<#call, Array(Object, Symbol)>]
  #
  # source://good_job//lib/good_job/poller.rb#31
  def recipients; end

  # Restart the poller.
  # When shutdown, start; or shutdown and start.
  #
  # @param timeout [Numeric, nil] Seconds to wait; shares same values as {#shutdown}.
  # @return [void]
  #
  # source://good_job//lib/good_job/poller.rb#79
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the timer is running.
  #
  # @return [true, false, nil]
  #
  # source://good_job//lib/good_job/poller.rb#48
  def running?(*_arg0, **_arg1, &_arg2); end

  # Shut down the poller.
  # Use {#shutdown?} to determine whether threads have stopped.
  #
  # @param timeout [nil, Numeric] Seconds to wait for active threads.
  #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
  #   * +-1+, the scheduler will wait until the shutdown is complete.
  #   * +0+, the scheduler will immediately shutdown and stop any threads.
  #   * A positive number will wait that many seconds before stopping any remaining active threads.
  # @return [void]
  #
  # source://good_job//lib/good_job/poller.rb#64
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the timer is shutdown.
  #
  # @return [true, false, nil]
  #
  # source://good_job//lib/good_job/poller.rb#52
  def shutdown?; end

  # Invoked on completion of TimerTask task.
  #
  # @param time [Integer]
  # @param executed_task [Object, nil]
  # @param thread_error [Exception, nil]
  # @return [void]
  #
  # source://good_job//lib/good_job/poller.rb#90
  def timer_observer(time, executed_task, thread_error); end

  private

  # @return [void]
  #
  # source://good_job//lib/good_job/poller.rb#101
  def create_timer; end

  # @return [Concurrent::TimerTask]
  #
  # source://good_job//lib/good_job/poller.rb#98
  def timer; end

  class << self
    # Creates GoodJob::Poller from a GoodJob::Configuration instance.
    #
    # @param configuration [GoodJob::Configuration]
    # @return [GoodJob::Poller]
    #
    # source://good_job//lib/good_job/poller.rb#25
    def from_configuration(configuration); end

    # List of all instantiated Pollers in the current process.
    #
    # @return [Array<GoodJob::Poller>, nil]
    #
    # source://good_job//lib/good_job/poller.rb#20
    def instances; end
  end
end

# Defaults for instance of Concurrent::TimerTask.
# The timer controls how and when sleeping threads check for new work.
#
# source://good_job//lib/good_job/poller.rb#11
GoodJob::Poller::DEFAULT_TIMER_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://good_job//lib/good_job/probe_server.rb#4
class GoodJob::ProbeServer
  # @return [ProbeServer] a new instance of ProbeServer
  #
  # source://good_job//lib/good_job/probe_server.rb#13
  def initialize(port:); end

  # source://good_job//lib/good_job/probe_server.rb#35
  def call(env); end

  # @return [Boolean]
  #
  # source://good_job//lib/good_job/probe_server.rb#26
  def running?; end

  # source://good_job//lib/good_job/probe_server.rb#17
  def start; end

  # source://good_job//lib/good_job/probe_server.rb#30
  def stop; end

  class << self
    # source://good_job//lib/good_job/probe_server.rb#7
    def task_observer(time, output, thread_error); end
  end
end

# source://good_job//lib/good_job/probe_server.rb#5
GoodJob::ProbeServer::RACK_SERVER = T.let(T.unsafe(nil), String)

class GoodJob::Process < ::GoodJob::BaseRecord
  include ::GoodJob::Process::GeneratedAttributeMethods
  include ::GoodJob::Process::GeneratedAssociationMethods
  include ::GoodJob::AssignableConnection
  include ::GoodJob::Lockable
  extend ::GoodJob::AssignableConnection::ClassMethods
  extend ::GoodJob::Lockable::ClassMethods

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#56
  def _connection; end

  # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#100
  def _connection=(obj); end

  def _current_id; end
  def _current_id=(val); end
  def _pid; end
  def _pid=(val); end
  def advisory_lockable_function; end
  def advisory_lockable_function=(_arg0); end
  def advisory_lockable_function?; end
  def basename; end
  def create_with_advisory_lock; end
  def create_with_advisory_lock=(_arg0); end
  def deregister; end
  def mutex; end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#48
    def _connection; end

    # source://activesupport/7.0.4.3/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#92
    def _connection=(obj); end

    def _current_id; end
    def _current_id=(val); end
    def _pid; end
    def _pid=(val); end

    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def active(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def advisory_lock(*args, **_arg1); end

    def advisory_lockable_column; end
    def advisory_lockable_column=(value); end
    def advisory_lockable_column?; end
    def advisory_lockable_function; end
    def advisory_lockable_function=(value); end
    def advisory_lockable_function?; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def advisory_locked(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def advisory_unlocked(*args, **_arg1); end

    def cleanup; end
    def current_id; end
    def current_state; end

    # source://activerecord/7.0.4.3/lib/active_record/enum.rb#116
    def defined_enums; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def inactive(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def includes_advisory_locks(*args, **_arg1); end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def joins_advisory_locks(*args, **_arg1); end

    def mutex; end

    # source://activerecord/7.0.4.3/lib/active_record/scoping/named.rb#174
    def owns_advisory_locked(*args, **_arg1); end

    def register; end
  end
end

module GoodJob::Process::GeneratedAssociationMethods; end
module GoodJob::Process::GeneratedAttributeMethods; end

class GoodJob::ProcessesController < ::GoodJob::ApplicationController
  def index; end

  private

  # source://actionview/7.0.4.3/lib/action_view/layouts.rb#328
  def _layout(lookup_context, formats); end

  def _layout_from_proc; end

  class << self
    # source://actionpack/7.0.4.3/lib/action_controller/metal.rb#210
    def middleware_stack; end
  end
end

module GoodJob::Reportable
  def last_status_at; end
  def status; end
end

class GoodJob::ScheduledByQueueChart
  def initialize(filter); end

  def data; end
  def string_to_hsl(string); end
end

# Schedulers are generic thread pools that are responsible for
# periodically checking for available tasks, executing tasks within a thread,
# and efficiently scaling active threads.
#
# Every scheduler has a single {JobPerformer} that will execute tasks.
# The scheduler is responsible for calling its performer efficiently across threads managed by an instance of +Concurrent::ThreadPoolExecutor+.
# If a performer does not have work, the thread will go to sleep.
# The scheduler maintains an instance of +Concurrent::TimerTask+, which wakes sleeping threads and causes them to check whether the performer has new work.
#
# source://good_job//lib/good_job/scheduler.rb#18
class GoodJob::Scheduler
  # @param performer [GoodJob::JobPerformer]
  # @param max_threads [Numeric, nil] number of seconds between polls for jobs
  # @param max_cache [Numeric, nil] maximum number of scheduled jobs to cache in memory
  # @param warm_cache_on_initialize [Boolean] whether to warm the cache immediately, or manually by calling +warm_cache+
  # @param cleanup_interval_seconds [Numeric, nil] number of seconds between cleaning up job records
  # @param cleanup_interval_jobs [Numeric, nil] number of executed jobs between cleaning up job records
  # @raise [ArgumentError]
  # @return [Scheduler] a new instance of Scheduler
  #
  # source://good_job//lib/good_job/scheduler.rb#74
  def initialize(performer, max_threads: T.unsafe(nil), max_cache: T.unsafe(nil), warm_cache_on_initialize: T.unsafe(nil), cleanup_interval_seconds: T.unsafe(nil), cleanup_interval_jobs: T.unsafe(nil)); end

  # Preload existing runnable and future-scheduled jobs
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#254
  def cleanup; end

  # Wakes a thread to allow the performer to execute a task.
  #
  # @param state [Hash, nil] Contextual information for the performer. See {JobPerformer#next?}.
  # @return [Boolean, nil] Whether work was started.
  #
  #   * +nil+ if the scheduler is unable to take new work, for example if the thread pool is shut down or at capacity.
  #   * +true+ if the performer started executing work.
  #   * +false+ if the performer decides not to attempt to execute a task based on the +state+ that is passed to it.
  #
  # source://good_job//lib/good_job/scheduler.rb#154
  def create_thread(state = T.unsafe(nil)); end

  # Human readable name of the scheduler that includes configuration values.
  #
  # @return [String]
  #
  # source://good_job//lib/good_job/scheduler.rb#66
  def name; end

  # Restart the Scheduler.
  # When shutdown, start; or shutdown and start.
  #
  # @param timeout [Numeric] Seconds to wait for actively executing jobs to finish; shares same values as {#shutdown}.
  # @raise [ArgumentError]
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#137
  def restart(timeout: T.unsafe(nil)); end

  # Tests whether the scheduler is running.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/scheduler.rb#97
  def running?(*_arg0, **_arg1, &_arg2); end

  # Shut down the scheduler.
  # This stops all threads in the thread pool.
  # Use {#shutdown?} to determine whether threads have stopped.
  #
  # @param timeout [Numeric, nil] Seconds to wait for actively executing jobs to finish
  #   * +nil+, the scheduler will trigger a shutdown but not wait for it to complete.
  #   * +-1+, the scheduler will wait until the shutdown is complete.
  #   * +0+, the scheduler will immediately shutdown and stop any active tasks.
  #   * A positive number will wait that many seconds before stopping any remaining active tasks.
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#112
  def shutdown(timeout: T.unsafe(nil)); end

  # Tests whether the scheduler is shutdown.
  #
  # @return [Boolean, nil]
  #
  # source://good_job//lib/good_job/scheduler.rb#101
  def shutdown?(*_arg0, **_arg1, &_arg2); end

  # Information about the Scheduler
  #
  # @return [Hash]
  #
  # source://good_job//lib/good_job/scheduler.rb#216
  def stats; end

  # Invoked on completion of ThreadPoolExecutor task
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#199
  def task_observer(time, output, thread_error); end

  # Preload existing runnable and future-scheduled jobs
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#230
  def warm_cache; end

  private

  # source://good_job//lib/good_job/scheduler.rb#309
  def cache_count; end

  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#276
  def create_executor; end

  # @param delay [Integer]
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#285
  def create_task(delay = T.unsafe(nil)); end

  # Returns the value of attribute executor.
  #
  # source://good_job//lib/good_job/scheduler.rb#273
  def executor; end

  # @param name [String]
  # @param payload [Hash]
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#299
  def instrument(name, payload = T.unsafe(nil), &block); end

  # Returns the value of attribute performer.
  #
  # source://good_job//lib/good_job/scheduler.rb#273
  def performer; end

  # source://good_job//lib/good_job/scheduler.rb#313
  def remaining_cache_count; end

  # Returns the value of attribute timer_set.
  #
  # source://good_job//lib/good_job/scheduler.rb#273
  def timer_set; end

  class << self
    # Creates GoodJob::Scheduler(s) and Performers from a GoodJob::Configuration instance.
    #
    # @param configuration [GoodJob::Configuration]
    # @param warm_cache_on_initialize [Boolean]
    # @return [GoodJob::Scheduler, GoodJob::MultiScheduler]
    #
    # source://good_job//lib/good_job/scheduler.rb#41
    def from_configuration(configuration, warm_cache_on_initialize: T.unsafe(nil)); end

    # List of all instantiated Schedulers in the current process.
    #
    # @return [Array<GoodJob::Scheduler>, nil]
    #
    # source://good_job//lib/good_job/scheduler.rb#35
    def instances; end
  end
end

# Defaults for instance of Concurrent::ThreadPoolExecutor
# The thread pool executor is where work is performed.
#
# source://good_job//lib/good_job/scheduler.rb#21
GoodJob::Scheduler::DEFAULT_EXECUTOR_OPTIONS = T.let(T.unsafe(nil), Hash)

# Custom sub-class of +Concurrent::ThreadPoolExecutor+ to add additional worker status.
#
# @private
#
# source://good_job//lib/good_job/scheduler.rb#319
class GoodJob::Scheduler::ThreadPoolExecutor < ::Concurrent::ThreadPoolExecutor
  # Number of inactive threads available to execute tasks.
  # https://github.com/ruby-concurrency/concurrent-ruby/issues/684#issuecomment-427594437
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/scheduler.rb#323
  def ready_worker_count; end
end

# Custom sub-class of +Concurrent::TimerSet+ for additional behavior.
#
# @private
#
# source://good_job//lib/good_job/scheduler.rb#338
class GoodJob::Scheduler::TimerSet < ::Concurrent::TimerSet
  # Number of scheduled jobs in the queue
  #
  # @return [Integer]
  #
  # source://good_job//lib/good_job/scheduler.rb#341
  def length; end

  # Clear the queue
  #
  # @return [void]
  #
  # source://good_job//lib/good_job/scheduler.rb#347
  def reset; end
end

class GoodJob::Setting < ::GoodJob::BaseRecord
  include ::GoodJob::Setting::GeneratedAttributeMethods
  include ::GoodJob::Setting::GeneratedAssociationMethods

  class << self
    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators; end

    def cron_key_disable(key); end
    def cron_key_enable(key); end
    def cron_key_enabled?(key); end

    # source://activerecord/7.0.4.3/lib/active_record/enum.rb#116
    def defined_enums; end
  end
end

GoodJob::Setting::CRON_KEYS_DISABLED = T.let(T.unsafe(nil), String)
module GoodJob::Setting::GeneratedAssociationMethods; end
module GoodJob::Setting::GeneratedAttributeMethods; end

# GoodJob gem version.
#
# source://good_job//lib/good_job/version.rb#4
GoodJob::VERSION = T.let(T.unsafe(nil), String)
